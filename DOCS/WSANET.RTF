{\rtf1\ansi \deff0\deflang1024{\fonttbl{\f0\froman Times;}{\f1\froman Symbol;}{\f2\fswiss Helvetica;}{\f3\froman Times;}{\f4\fswiss Helvetica;}{\f5\fswiss MS Sans Serif;}{\f6\fnil Wingdings;}{\f7\fmodern Courier New;}
{\f8\fmodern Courier;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue127;\red0\green127\blue127;
\red0\green127\blue0;\red127\green0\blue127;\red127\green0\blue0;\red127\green127\blue0;\red127\green127\blue127;\red192\green192\blue192;}{\stylesheet{\s228\li2880\ri720\tldot\tx8280\tqr\tx8640 \f3\fs20\lang1033 \sbasedon0\snext0 toc 5;}{
\s229\li2160\ri720\tldot\tx8280\tqr\tx8640 \f3\fs20\lang1033 \sbasedon0\snext0 toc 4;}{\s230\li1440\ri720\tldot\tx8280\tqr\tx8640 \f3\fs20\lang1033 \sbasedon0\snext0 toc 3;}{\s231\li720\ri720\tldot\tx8280\tqr\tx8640 \f3\fs20\lang1033 
\sbasedon0\snext0 toc 2;}{\s232\ri720\tldot\tx8280\tqr\tx8640 \f3\fs20\lang1033 \sbasedon0\snext0 toc 1;}{\s233\li2160 \f3\fs20\lang1033 \sbasedon0\snext0 index 7;}{\s234\li1800 \f3\fs20\lang1033 \sbasedon0\snext0 index 6;}{\s235\li1440 \f3\fs20\lang1033 
\sbasedon0\snext0 index 5;}{\s236\li1080 \f3\fs20\lang1033 \sbasedon0\snext0 index 4;}{\s237\li720 \f3\fs20\lang1033 \sbasedon0\snext0 index 3;}{\s238\li360 \f3\fs20\lang1033 \sbasedon0\snext0 index 2;}{\s239 \f3\fs20\lang1033 \sbasedon0\snext0 index 1;}{
\s240 \f3\fs20\lang1033 \sbasedon0\snext0 line number;}{\s241 \f3\fs20\lang1033 \sbasedon0\snext239 index heading;}{\s242\tqc\tx4320\tqr\tx8640 \f3\fs20\lang1033 \sbasedon0\snext242 footer;}{\s243\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 
\b\f4\lang1033 \sbasedon0\snext243 header;}{\s244 \f3\fs16\up6\lang1033 \sbasedon0\snext0 footnote reference;}{\s245 \f3\fs20\lang1033 \sbasedon0\snext245 footnote text;}{\s246\li720 \i\f3\fs20\lang1033 \sbasedon0\snext255 heading 9;}{\s247\li720 
\i\f3\fs20\lang1033 \sbasedon0\snext255 heading 8;}{\s248\li720 \i\f3\fs20\lang1033 \sbasedon0\snext255 heading 7;}{\s249\li720 \f3\fs20\ul\lang1033 \sbasedon0\snext255 heading 6;}{\s250\li720 \b\f3\fs20\lang1033 \sbasedon0\snext255 heading 5;}{
\s251\li360 \b\f3\fs20\lang1033 \sbasedon0\snext255 heading 4;}{\s252\li360 \b\f3\fs20\lang1033 \sbasedon0\snext255 heading 3;}{\s253\sb120 \b\f4\fs20\lang1033 \sbasedon0\snext0 heading 2;}{\s254\sb240 \b\f4\fs20\ul\lang1033 \sbasedon0\snext0 heading 1;}{
\s255\li720 \f3\fs20\lang1033 \sbasedon0\snext255 Normal Indent;}{\f3\fs20\lang1033 \snext0 Normal;}{\s2\fi-1440\li1440 \f3\fs20\lang1033 \sbasedon0\snext2 desc;}{\s3\fi-1080\li1080 \b\f4\fs20\lang1033 \sbasedon0\snext3 include;}{\s4\fi-1080\li1080 
\b\f4\fs20\lang1033 \sbasedon0\snext4 syntax;}{\s5\fi-1440\li1440 \f3\fs20\lang1033 \sbasedon0\snext12 descrip;}{\s6\fi-1440\li2880 \f3\fs20\ul\lang1033 \sbasedon0\snext6 param;}{\s7\fi-1440\li1440 \f3\fs20\lang1033 \sbasedon0\snext7 returns;}{
\s8\fi-4320\li4320\keep\tx1440\tx4320 \f3\fs20\lang1033 \sbasedon0\snext11 errors;}{\s9\fi-1440\li1440\tx1440 \b\f4\fs20\lang1033 \sbasedon0\snext9 see;}{\s10\fi-1440\li2880 \f3\fs20\lang1033 \sbasedon6\snext10 paramtext;}{
\s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \f3\fs20\lang1033 \sbasedon8\snext11 errors2;}{\s12\li1440 \f3\fs20\lang1033 \sbasedon5\snext12 descrip2;}{\s13\fi-1440\li2880 \f3\fs20\lang1033 \sbasedon0\snext13 returns2;}{\s14\li1440 \f3\fs20\lang1033 
\sbasedon0\snext14 returns3;}{\s15\li2160 \f3\fs20\lang1033 \sbasedon10\snext15 val;}{\s16\li2160 \f3\fs20\ul\lang1033 \sbasedon0\snext16 val1;}{\s17\li2160 \f3\fs20\lang1033 \sbasedon0\snext17 val2;}{\s18\fi-360\li1800\tx3600 \f3\fs20\lang1033 
\sbasedon12\snext18 descrip3;}{\s19\fi-2160\li3600\tx3600 \f3\fs20\lang1033 \sbasedon18\snext19 descrip4;}{\s20\fi-1440\li3600 \f3\fs20\ul\lang1033 \sbasedon16\snext20 val3;}{\s21\fi-1440\li3600 \f3\fs20\lang1033 \sbasedon17\snext21 val4;}{
\s22\fi-1440\li1440 \f3\fs20\lang1033 \sbasedon0\snext22 notes;}{\s23\li1440 \f3\fs20\lang1033 \sbasedon0\snext23 notes2;}{\s24\fi-2160\li3600 \f3\fs20\ul\lang1033 \sbasedon0\snext24 Notes3;}{\s25\fi-2160\li3600\tx4320 \f3\fs20\lang1033 
\sbasedon0\snext25 Notes4;}{\s26\fi-1440\li1440 \f3\fs20\lang1033 \sbasedon0\snext26 comments;}{\s27\fi-2160\li3600\tx4140\tx5760 \f3\fs20\ul\lang1033 \sbasedon0\snext27 errors3;}{\s28\li1440 \f3\fs20\lang1033 \sbasedon0\snext28 errors4;}{\s29\li1440 
\f7\fs20\lang1033 \sbasedon12\snext29 code;}{\s30\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760 \f7\fs16\lang1033 \sbasedon0\snext30 hdr-file-code;}{\s31\keep\keepn \f7\fs16\lang1033 \sbasedon30\snext31 err-table;}{\s32\fi-1440\li2880 
\f7\fs20\lang1033 \sbasedon10\snext32 paramcode;}{\s33\keepn \b\f3\fs20\lang1033 \snext33 NormalHead;}{\s34\qc\sa240 \b\f4\lang1033 \sbasedon252\snext34 Title;}{\s35\sa240 \b\f4\fs20\lang1033 \sbasedon34\snext35 Title2;}{\s36\fi-1080\li1080\tx1080 
\f4\fs20\lang1033 \sbasedon3\snext36 Function;}}{\info{\title WSNETC Help File}{\subject WinSock Client Control Help File}{\author John Blenke}{\keywords WinSock VBX}{\doccomm This is a HLP file for WSANET.VBX. Version 1.07alpha's documentation.}
{\operator John Blenke}{\creatim\yr1993\mo12\dy18\hr12\min48}{\revtim\yr1993\mo12\dy21\hr22\min47}{\version9}{\edmins104}{\nofpages109}{\nofwords82036}{\nofchars93784}{\vern16431}}\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\gutter0 
\widowctrl\ftnbj \sectd \linex0\endnhere \pard\plain \qc\keepn \f3\fs20\lang1033 {\fs16\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} CONTENTS}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $ }Contents}}{
\fs16\up6 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K}Contents}}{\plain \b\f5\lang1033  WinSock Networking VBX }{\plain \b\f5\cf2\lang1033 v1.08}{\plain \b\i\f5\cf2\lang1033 alpha}{\plain \b\f5\cf2\lang1033  }{\plain \b\f5\lang1033 HELP

\par }\pard {\f5 When you add this VBX to your project, three new custom controls will be added to yo}{\f5 ur Toolbox. You can select the appropriate control by clicking the corresponding button.
\par }{\f5 
\par }\pard \li180 {\f5 See }{\f5\uldb About this project}{\v\f5 TOPIC_ABOUT}{\f5  for more general information
\par }{\f5 See the }{\f5\uldb Changes}{\v\f5 TOPIC_CHANGES}{\f5  that have been made to this version.
\par }{\f5 See the public domain }{\f5\uldb Copyright}{\v\f5 TOPIC_COPYRIGHT}{\f5  information for distribution availability.
\par }{\f5 See the }{\f5\uldb Common Problems}{\v\f5 TOPIC_COMMONPROBLEMS}{\f5  information for general help on other issues.
\par }\pard {\f5 
\par }{\f5 The toolbox buttons available through WSANET.VBX are:
\par }\trowd \trgaph108\trleft252 \cellx2967\cellx5427\cellx7272\pard \qc\intbl {\f5 \{bmc netclnt.bmp\} }{\f5\uldb NetClient control}{\v\f5 TOPIC_CONTROL_N}{\v\f5 ETCLIENT}{\f5 \cell }{\f5 \{bmc netsrvr.bmp\} }{\f5\uldb NetServer control}{\v\f5 
TOPIC_CONTROL_NETSERVER}{\f5 \cell }{\f5 \{bmc ini.bmp\} }{\f5\uldb Ini control}{\v\f5 TOPIC_CONTROL_INI}{\f5 \cell }\pard \intbl {\f5 \row }\pard {\f5 \page }{\fs16\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_DNS}}{\f5  }{
\b\f5 D}{\f5 omain }{\b\f5 N}{\f5 ame }{\b\f5 S}{\f5 ystem\page }{\fs16\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_FQDN}}{\f5  }{\b\f5 F}{\f5 ully }{\b\f5 Q}{\f5 ualified }{\b\f5 D}{\f5 omain }{\b\f5 N}{\f5 ame
\par }{\f5 \page }{\fs16\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_BSD}}{\f5  }{\b\f5 B}{\f5 erkley }{\b\f5 S}{\f5 oftware }{\b\f5 D}{\f5 istribution\page }{\fs16\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #}
 POPUP_FIFO}}{\f5  }{\b\f5 F}{\f5 irst }{\b\f5 I}{\f5 n }{\b\f5 F}{\f5 irst }{\b\f5 O}{\f5 ut
\par }\pard \qc\keepn {\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} TOPIC_ABOUT}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} About the NetClient Project}}{\fs16\up6 K
{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} About the NetClient Project;About the Author;About}}{\plain \b\f5\lang1033  \{bmc netsrvr.bmp\} \{bmc netclnt.bmp\} \{bmc ini.bmp\} About the WinSock Networking VBX Project 
\par }\pard {\b\f5 
\par }{\b\f5 About the NetClient Control
\par }\pard \qj\li180 {\f5 This control was written between July and December of 1993 as a side project to other Windows Sockets applications. Somehow, between 3 harddrive crashes, this }{\f5 
project managed to survive to the stage you see it in today. NetClient's origional purpose was to fill the gap between the many Unix networking services and the moderate few WinSock applications.
\par }\pard {\f5 
\par }{\b\f5 About the Author
\par }\pard \li180 {\f5 (As of October of 1993)(In an attempt at modest second person tone)
\par }\pard \qj\li180 {\f5 
\par }{\f5 Ian Blenke is currently a full time student teaching himself the wonders of computing. He currently takes part in Windows Sockets discussions through Internet mail, and tries to read what he can through Usenet news. He has m}{\f5 
igrated from his developing stage on the Commodore 64 throughout high school as a "demo" programmer to the more advanced Unix and Windows paradigms in todays workplace. He currently has currently finished his initial 2 years at a local community college, 
}{\f5 and hopes to continue his education with either the Florida Institute of Technology (FIT) or the University of Central Florida (UCF) in their Software Engineering programs.
\par }{\f5 
\par }{\f5 Ian currently works as a COOP for Harris Corporation Corporate Headquarters in Me}{\f5 
lbourne, Florida. As a COOP he is kept busy putting PCs together, installing software, and occationally writing miscellaneous "hacks" to do such things as monitor the network with batch files and VB.  
\par }{\f5 
\par }{\f5 
Ian programs during his spare evenings at home. Since his college studies have began, he has devoted his personal software to the public domain. In the future he hopes to continue writing network and GUI applications for whatever OS has his eye at the tim
}{\f5 e. As time progresses, he hopes to continue to contr}{\f5 ibute to the new "Electronic Superhighway" (TM Gore) (I.E. Internet) as it expands into its full glory.
\par }{\f5 
\par }\pard \qj\fi-180\li180 {\b\f5 E-Mail addresses:
\par }\pard \qj\li180 {\f5 iblenke@ic1d.harris.com
\par }{\f5 iblenke@rhino.ess.harris.com
\par }\pard \keepn {\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} TOPIC_THANKS}}{\plain \b\f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Thank you's and Handshakes}}{\plain 
\b\f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Thanks;About}}{\plain \b\f5\lang1033  Thank you's and Handshakes
\par }\pard \qj\li180 {\f5 
This section is devoted to you. Whenever I receive a good idea, or a successful nudge to implement something new or fix an outstanding bug, I will try and remember and put your name in here. If I don't, simply remind me, and I will gladly put you in (beca
}{\f5 use I realize that I have a very short memo}{\f5 ry ;).
\par }\pard \qj {\f5 
\par }\pard \qj\fi-540\li540\tx1440 {\f5 \tab For the idea of a WinSock control at all, I would like to thank G. Michael Carr, a co-worker. If it weren't for his daily trips to bug me about finishing it, you would likely have never read this!
\par }{\f5 
\par }{\f5 \tab For the idea of RSH/LPD type restricted port clients, I would like to thank Dan Tenenbaum at Microsoft. This was on my agenda - I just didn't feel like implementing it, but his persistance gave me a reason to implement the }{\f5\uldb LocalPort}
{\v\f5 NETCLIENT_PROPERTY_LOCALPORT}{\f5  property. He also aided the project by }{\f5 
creating a VC++ makefile, reporting a whole slew of warnings from the VC++ compiler (which, hopefully, have been fixed), and noting that WEP was unnecessarily exported in the WSNETC.DEF file (a holdover from an earlier revision). 
\par }\pard \qj\fi-540\li540 {\f5 
\par }{\f5 \tab 
For relaying constant feedback as to the status of his Sequoia program, I would like to thank Jason Levine at Columbia University. Jason has spent an incredible amount of time getting his Sequoia program to work with WSMTPD and the WSANET VBX. I have to }
{\f5 thank you for the amoun}{\f5 t of time you've put into this wonderful mail program.
\par }\pard \qj\fi-360\li540 {\f5 
\par }\pard \qj\fi-540\li540 {\f5 \tab 
For testing and reporting bugs at the WinSock level over Peter Tattam's WinSock, I would like to thank Mike Rogers at the University of Iowa. His comments relate both to the real world problems that might occur with the NetClient control, and to the prob}
{\f5 lems that users will face with my VB3.0 only examples (which HAVE been rewritten for VB2.0 standard).
\par }{\f5 
\par }{\f5 \tab For testing the Block/SendBlock/RecvBlock properties with his Gopher client, I would like to }{\f5 
thank Rod Potter from York University (Computing & Communications Services). By looking at his CNGopher source code, I have corrected some of the online help documentation by seeing what everyone expects the VBX to do.
\par }{\f5 
\par }{\f5 \tab For suggesting the }{\f5\uldb Host}{\v\f5 NETCLIENT_PROPERTY_HOST}{\f5 
 property (for the heck of it), and for giving me ideas for UDP, OOB, and Raw socket support in the future, I would like to thank Tom Hogard from the Air Force Logistics Command.  
\par }{\f5 
\par }\pard \keepn {\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} TOPIC_COMMONPROBLEMS}}{\plain \b\f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Common Problems}}{\plain 
\b\f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Common Problems}}{\plain \b\f5\lang1033  Common Problems with WSANET.VBX (FAQ)
\par }\pard {\f5 
\par }\pard \fi-360\li360 {\f7 Q.}{\f5  }{\i\f5 Whenever I}{\i\f5  use WSANET.VBX in my project, my machine slows to a crawl!
\par }\pard \fi-450\li630\tx630 {\f7 A.\tab }{\f5 
This problem is due to the fact that you are using the debugging version of the VBX. In order to remedy this problem, you MUST run DBWIN.EXE or OX.SYS in order to install the debugging "hook" that Windows keeps looking for during each OutputDebugString() 
}{\f5 call. The other solution is to use RELEASE.VBX by renaming it to WSANET.VBX - it uses no such debugging calls - and it will definitely run faster. Due to the massive output of the debugging ver}{\f5 
sion, you might consider using the RELEASE.VBX version (by copying it to your SYSTEM directory as WSANET.VBX) until you stumble upon a bug.
\par }\pard {\f7 
\par }\pard \fi-360\li360 {\f7 Q.}{\f5  }{\i\f5 Whenever I try to send a large file, I get wierd results! What gives?
\par }\pard \fi-450\li630\tx630 {\f7 A.}{\f5 \tab 
This is a side-effect of asyncronous programming. In order to send more data than can be held in your WINSOCK.DLL's buffers, and NetClient's send buffers, you MUST either poll SendCount or use the SendThreshold/OnSend() pair. See the WFingerD or VBSMTPD }
{\f5 example of how to do exactly this.
\par }\pard \fi-360\li360 {\f7 
\par }{\f7 Q.}{\f5  }{\i\f5 Your example programs are written explicitly for VB2.0 and newer! What about VB1.0 users? 
\par }\pard \fi-450\li630\tx630 {\f7 A.\tab }{\f5 
Unfortunately, the author does not have VB1.0 or VC++ (MFC 2.0) to test out or write sample applications. He has, however, tried to make the text-saved VB2.0 examples generic enough for VB1.0 use. You merely have to load an example form into a text editor
}{\f5  (like Notepad) and use the Copy function - then Paste what you copied into a VB1.0 form. 
\par }\pard {\f5 
\par }\pard \fi-270\li270 {\f7 Q.}{\f5  }{\i\f5 What are your plans for this VBX?
\par }\pard \fi-450\li630\tx630 {\f7 A.\tab }{\f5 WSANET.VBX is intended t}{\f5 
o be used by Public Domain application authors as a FREEWARE tool. This entire project is merely a pet project of mine to get TCP/IP applications quickly to the end-users - as FREEWARE. The Windows Socket v1.1 standard was a feat in itself, but the only r
}{\f5 
eal world applications that I have seen on Internet are Shareware packages and commercial demos. This tool will make EVERY client/server application available on Unix to be written for Windows 3.x and newer (as long as a WINSOCK.DLL thunk is included). Th
}{\f5 e }{\f5 main reason for this control, trying not to sound ego-centered, was to show that I have some potential as a future Software Engineer.
\par }\pard {\f5 
\par }\pard \keepn {\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} TOPIC_SOCKET}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} What is a socket?}}{\plain 
\f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Socket Concept;Client/Server paradigm;BSD Sockets}}{\plain \f5\lang1033  }{\plain \b\f5\lang1033  \{bmc netclnt.bmp\} What is a Socket?
\par }\pard {\f5 
\par }\pard \qj {\f5 The concept of Sockets is derived from the network programming model on }{\f5\ul BSD}{\v\f5 POPUP_BSD}{\f5 
 Unix. A socket was origionally intended as a way for two machines to talk across the network without the hassle of packet derived communication. \tab 
\par }{\f5 
\par }{\f5 A Socket is (at least on NT and Unix) a unique "handle" that can be used on the system to refer}{\f5 
ence the connection to another host. A Socket has 2 sides to it: Local and Remote. The Local side uses your PC's TCP/IP address (actually INADDR_ANY for WinSock calls) and the }{\f5\uldb LocalPort}{\v\f5 NETCLIENT_PROPERTY_LOCALPORT}{\f5 
 property to define the application's side of the connection. By setting }{\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5  (I.P.) or }{\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5  (}{\f5\ul DNS}{\v\f5 POPUP_DNS}{\f5 ) and the }{
\f5\uldb RemotePort}{\v\f5 NETCLIENT_PROPERTY_REMOTEPORT}{\f5  to a remote host's TCP address, you tell the NetClient control where to connect t}{\f5 o.
\par }{\f5 
\par }{\f5 By using this control, the NetClient control itself becomes the Socket. You can set the }{\f5\uldb LocalPort}{\v\f5 NETCLIENT_PROPERTY_LOCALPORT}{\f5  and }{\f5\uldb RemotePort}{\v\f5 NETCLIENT_PROPERTY_REMOTEPORT}{\f5 
 properties to allow the control to bind() both sides of a real WinSock socket appropriately. When you set the }{\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5  or }{\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5 
 property, you are telling the control that it is to try and connect to that address. Once you set }{\f5\uldb Connect}{\v\f5 NETCLIENT_PROPERTY_CONNECT}{\f5  to True, you allow }{\f5 
the control to allocate a real WinSock socket to attempt a connection to the remote host.  If you use the Index property, you can have multiple Windows Sockets client connections active simultaneously. Each control in the control array receives its own Wi
}{\f5 nSock "environment" that you can use to communicate across the network.
\par }\pard \keepn {\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} TOPIC_WINSOCKERRORS}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} WinSock Errors}}{\fs16\up6 K{\footnote 
\pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Errors}}{\plain \b\f5\lang1033  WinSock Errors
\par }\pard {\f5 
\par }{\f4 The following is a list of possible error codes returned by the NetClient control, along with their explanations.  The error numbers are consistently set across }{\f4 all Windows Sockets-compliant implementations.
\par }\pard\plain \s31\fi-5400\li6840\keep\tx1440\tx3600\tx5760\tx7200 \f7\fs16\lang1033 {\f4 
\par }\pard \s31\fi-5040\li5760\tx720\tx2880\tx4770\tx5760 {\b\f4\ulw Windows Sockets code\tab Berkeley equivalent\tab Error\tab Interpretation
\par }{\f4 WSAEINTR\tab EINTR\tab 10004\tab As in standard C
\par }{\f4 WSAEBADF\tab EBADF\tab 10009\tab As in standard C
\par }{\f4 WSEACCES\tab EACCES\tab 10013\tab As in standard C
\par }{\f4 WSAEFAULT\tab EFAULT\tab 10014\tab As in standard C
\par }{\f4 WSAEINVAL\tab EINVAL\tab 10022\tab As in standard C
\par }{\f4 WSAEMFILE\tab EMFILE\tab 10024\tab As in standard C
\par }{\f4 WSAEWOULDBLOCK\tab EWOULDBLOCK\tab 10035\tab As in BSD
\par }{\f4 WSAEINPROGRESS\tab EINPROGRESS\tab 10036\tab This error is returned if anyWindows Sockets API function is called while a block}{\f4 ing function is in progress.
\par }{\f4 WSAEALREADY\tab EALREADY\tab 10037\tab As in BSD
\par }{\f4 WSAENOTSOCK\tab ENOTSOCK\tab 10038\tab As in BSD
\par }{\f4 WSAEDESTADDRREQ\tab EDESTADDRREQ\tab 10039\tab As in BSD
\par }{\f4 WSAEMSGSIZE\tab EMSGSIZE\tab 10040\tab As in BSD
\par }{\f4 WSAEPROTOTYPE\tab EPROTOTYPE\tab 10041\tab As in BSD
\par }{\f4 WSAENOPROTOOPT\tab ENOPROTOOPT\tab 10042\tab As in BSD
\par }{\f4 WSAEPROTONOSUPPORT\tab EPROTONOSUPPORT\tab 10043\tab As in BSD
\par }{\f4 WSAESOCKTNOSUPPORT\tab ESOCKTNOSUPPORT\tab 10044\tab As in BSD
\par }{\f4 WSAEOPNOTSUPP\tab EOPNOTSUPP\tab 10045\tab As in BSD
\par }{\f4 WSAEPFNOSUPPORT\tab EPFNOSUPPORT\tab 10046\tab As in BSD
\par }{\f4 WSAEAFNOSUPPORT\tab EAFNOSUPPORT\tab 10047\tab As in BSD}{\f4 
\par }{\f4 WSAEADDRINUSE\tab EADDRINUSE\tab 10048\tab As in BSD
\par }{\f4 WSAEADDRNOTAVAIL\tab EADDRNOTAVAIL\tab 10049\tab As in BSD
\par }{\f4 WSAENETDOWN\tab ENETDOWN\tab 10050\tab As in BSD.  This error may be reported at any time if the Windows Sockets implementation detects an underlying failure.
\par }{\f4 WSAENETUNREACH\tab ENETUNREACH\tab 10051\tab As in BSD
\par }{\f4 WSAENETRESET\tab ENETRESET\tab 10052\tab As in BSD
\par }{\f4 WSAECONNABORTED\tab ECONNABORTED\tab 10053\tab As in BSD
\par }{\f4 WSAECONNRESET\tab ECONNRESET\tab 10054\tab As in BSD
\par }{\f4 WSAENOBUFS\tab ENOBUFS\tab 10055\tab As in BSD
\par }{\f4 WSAEISCONN\tab EISCONN\tab 10056\tab As in BSD
\par }{\f4 WSAENOTCONN\tab ENOTCONN\tab 10057\tab A}{\f4 s in BSD
\par }{\f4 WSAESHUTDOWN\tab ESHUTDOWN\tab 10058\tab As in BSD
\par }{\f4 WSAETOOMANYREFS\tab ETOOMANYREFS\tab 10059\tab As in BSD
\par }{\f4 WSAETIMEDOUT\tab ETIMEDOUT\tab 10060\tab As in BSD
\par }{\f4 WSAECONNREFUSED\tab ECONNREFUSED\tab 10061\tab As in BSD
\par }{\f4 WSAELOOP\tab ELOOP\tab 10062\tab As in BSD
\par }{\f4 WSAENAMETOOLONG\tab ENAMETOOLONG\tab 10063\tab As in BSD
\par }{\f4 WSAEHOSTDOWN\tab EHOSTDOWN\tab 10064\tab As in BSD
\par }{\f4 WSAEHOSTUNREACH\tab EHOSTUNREACH\tab 10065\tab As in BSD
\par }{\f4 WSASYSNOTREADY\tab \tab 10091\tab Indicates that the network subsystem is unusable.
\par }{\f4 WSAVERNOTSUPPORTED\tab \tab 10092\tab Indicates that the Windows Sockets\line DLL cannot support this app.
\par }{\f4 WS}{\f4 ANOTINITIALISED\tab \tab 10093\tab Indicates that a successful }{\b\f4 WSAStartup()}{\f4  has not yet been performed.
\par }{\f4 WSAHOST_NOT_FOUND\tab HOST_NOT_FOUND\tab 11001\tab As in BSD.
\par }{\f4 WSATRY_AGAIN\tab TRY_AGAIN\tab 11002\tab As in BSD
\par }{\f4 WSANO_RECOVERY\tab NO_RECOVERY\tab 11003\tab As in BSD
\par }{\f4 WSANO_DATA\tab NO_DATA\tab 11004\tab As in BSD
\par }\pard\plain \f3\fs20\lang1033 {\f4 
\par }{\f4 The first set of definitions is present to resolve contentions between standard C error codes which may be defined inconsistently between various C compilers.
\par }{\f4 
\par }{\f4 The second set of definitions provides Windows Sockets versions of regular Berkeley }{\f4 Sockets error codes.
\par }{\f4 
\par }{\f4 The third set of definitions consists of extended Windows Sockets-specific error codes.
\par }{\f4 
\par }{\f4 The fourth set of errors are returned by Windows Sockets gethostbyXXXX() calls, and correspond to the errors which in Berkeley software would be returned in the }{\i\f4 h_errno}{\f4 
 variable.  They correspond to various failures which may be returned by the Domain Name Service.  If the Windows Sockets implementation  does not use the DNS, it will use the most appropriate code.  In general, a Windows Sockets}{\f4 
 application should interpret WSAHOST_NOT_FOUND and WSANO_DATA as indicating that the key (name, address, etc.) was not found,, while WSATRY_AGAIN and WSANO_RECOVERY suggest that the name service itself is non-operational.
\par }{\f4 
\par }{\f4 The error numbers are derived from the }{\b\f4 winsock.h}{\f4  header file, and are based on the fact that Windows Sockets error numbers are computed by adding 10000 to the "normal" Berkeley error number.
\par }{\f4 
\par }{\f4 Note that this table does not include all of the error codes defined in }{\b\f4 winsock.h}{\f4 .  This is }{\f4 because it includes only errors which might reasonably be returned by a Windows Sockets implementation: }{\b\f4 winsock.h}{\f4 
, on the other hand, includes a full set of BSD definitions to ensure compatibility with ported software.
\par }{\f4 
\par }{\f4 This Error section was "stolen" from the WinSock.HLP source file (winsockx.rtf, part of the Microdyne.com archives). You can get the actual WinSock.HLP file from a number of various FTP sites, along with the .H/.DEF/.LIB files and sample C sources. 

\par }\pard \qc\keepn {\plain \b\f5\up6\lang1033 \page }{\plain \b\f5\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} TOPIC_COPYRIGHT}}{\plain \b\f5\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Copyright}}
{\plain \b\f5\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Copyright;About}}{\plain \b\f5\lang1033  Copyright
\par }\pard {\f5 
\par }\pard \li180 {\f5 In this document, }{\b\f5 VBX}{\f5  refers to the actual Visual Basic control distributed with and based on this WSANET project, and }{\b\f5 author}{\f5  refers to }{\b\f5 Ian Blenke}{\f5 . The }{\b\f5 author}{\f5 
 cannot be held responsible for damages, express or implied, for the use of this software. No commercial use can be made of this product without the consent of the }{\b\f5 author}{\f5 
. No profit of any kind can be made on the sale or distribution of this program. If you wish to distribute this program with other samples of WinSock programming, you must first contact the }{\b\f5 author}{\f5  so that }{\f5 
he can keep accurate records of its usage; no charge may be made for this project's availability other than the cost of the physical medium used to store it on and any processing costs. If you write any programs based on this source code, including parts 
}{\f5 of this source code, or in some way derived from this source code, you may not sell them for any profit without the written consent of the }{\b\f5 author}{\f5 . If you incorporate this VBX into a }{\i\f5 free}{\f5  public domain program, all the }{
\b\f5 author}{\f5  requires is a notification that }{\f5 "The WinSock VBX control was written by }{\b\f5 Ian Blenke}{\f5 
" and some form of notification that his name was used in the public domain software distribution. No profit of any kind, shareware/commercial or otherwise, may be made for software based on this }{\b\f5 VBX}{\f5  without the written consent of the }{
\b\f5 author}{\f5 . This does not represent a contract on the part of the }{\b\f5 author}{\f5 . }{\i\f5 If any issues cannot clearly be resolved by reading this text, immediately contact the}{\f5  }{\b\f5 author}{\f5 . 
\par }\pard {\f5 
\par }\pard \li180 {\f5 The }{\b\f5 VBX}{\f5  control distributed with this project must be dist}{\f5 ributed with your programs free of charge. You cannot charge money for any program based on the }{\b\f5 VBX}{\f5  without the written consent of the }{\b\f5 
author}{\f5 .
\par }\pard {\f5 
\par }{\b\f5 Notes:
\par }{\f5 
\par }\pard \li180 {\f5 If you have any bug reports, by all means, tell me! I would be glad to help keep this code up to date. 
\par }{\f5 
\par }{\f5 The source of the project is included in the open spirit under which most Unix source is distributed: if you modify it in some unique way, PLEASE change the LIBRARY name in WSANET.DEF to match the filename of the finished VBX. This is to make sure t
}{\f5 
hat other WSANET applications continue to work as their designers intended. If you make any modifications, please contact the author  - your "hacks" could likely be incorporated into the next release of WSANET.VBX and  made available to other developers.}
{\f5 
\par }{\f5 
\par }{\f5 I don't like such agreements. But in today's world of lawyers and lawbreakers, I have little other choice. Enjoy!
\par }\pard \qc\keepn {\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} TOPIC_CHANGES}}{\plain \b\f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Version Changes}}{\plain 
\b\f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K}Changes}}{\plain \b\f5\lang1033  Changes
\par }\pard \li180 {\b\f5 v1.03alpha to v1.04alpha
\par }\pard \fi-180\li540 {\f5 Online context sensitive help is stable and complete (for this version)
\par }\pard \li180 {\f5 
\par }{\b\f5 v1.04alpha to v1.05alpha}{\b\f5 
\par }\pard \fi-180\li540 {\f5\uldb Socket}{\v\f5 NETCLIENT_PROPERTY_SOCKET}{\f5  semantics have changed (although the ability to set it is not
\par }{\f5       yet technically implemented).
\par }{\f5 New Toolbox BMP has been designed: 
\par }\pard \fi-2160\li2880\tx2880 {\f5 \{bmc netclnt.bmp\}\tab New (extended from SOCKET.ICO)
\par }{\f5 \{bmc old.bmp\}\tab Old (drawn by author, no artistic value ;)
\par }\pard \fi-180\li540 {\f5 HLP updated: }{\b\f5 Changes}{\f5  topic added.
\par }{\f5 The }{\f5\uldb LocalPort}{\v\f5 NETCLIENT_PROPERTY_LOCALPORT}{\f5  property was broken previous to version 1.05alpha. Setting it would set the }{\f5\uldb RemotePort}{\v\f5 NETCLIENT_PROPERTY_REMOTEPORT}{\f5  property.
\par }{\f5 WSNETC.C and NETC.C now use t}{\f5 he DEBUG_BUILD flag to mark debug/release build versions (instead of keeping two copies of source).
\par }{\f5 WSNETC.C cleaned up. Debugging information clearer now.
\par }{\f5 NETC.C cleaned up. Debugging information clearer now.
\par }{\f5 NET.C - Added "netConnect()" procedure to aid in the setting of the }{\f5\uldb Socket}{\v\f5 NETCLIENT_PROPERTY_SOCKET}{\f5  property
\par }{\f5 All sources cleaned up for compilation by VC++ (uncomment USE_VCPP in WSNetC.H)
\par }{\f5 Fixed }{\f5\uldb TimeOut}{\v\f5 NETCLIENT_PROPERTY_TIMEOUT}{\f5  bug. Previous versions will ALWAYS delay for just 1 second.
\par }\pard {\b\f5 
\par }{\b\f5 v1.05}{\b\f5 alpha to v1.06alpha
\par }\pard \fi-180\li540 {\f5 Added }{\f5\uldb Version}{\v\f5 NETCLIENT_PROPERTY_VERSION}{\f5  and }{\f5\uldb Debug}{\v\f5 NETCLIENT_PROPERTY_DEBUG}{\f5  properties.
\par }{\f5 Added }{\f5\uldb HostAliasCount}{\v\f5 NETCLIENT_PROPERTY_HOSTALIASCOUNT}{\f5 /}{\f5\uldb HostAliasList()}{\v\f5 NETCLIENT_PROPERTY_HOSTALIASLIST}{\f5  and }{\f5\uldb HostAddressCount}{\v\f5 NETCLIENT_PROPERTY_HOSTADDRESSCOUNT}{\f5 /}{\f5\uldb 
HostAddressList()}{\v\f5 NETCLIENT_PROPERTY_HOSTADDRESSLIST}{\f5  properties
\par }{\f5 Changed the HostAddr/HostName property code to avoid VB calls where possible.
\par }{\f5 Added }{\f5\uldb Ini}{\v\f5 TOPIC_CONTROL_INI}{\f5  Control - 6 properties, no events
\par }{\f5 Changed the names of EVERYTHING
\par }{\f5 Moved ev}{\f5 erything around
\par }{\f5 Caused general havok within the code:
\par }\pard \fi-180\li720 {\f5 Init.C is renamed to WSANet.C, and 2 procedures from WSNetC.C were added.
\par }{\f5 WSNetC.C is copied over to NetClnt.C
\par }{\f5 Ini.C/Ini.H is added (to support the Ini control)
\par }{\f5 WSNetC.H becomes two files: NetClnt.H and WSANet.H
\par }{\f5 Functions added to Net.C: GetAtomHsz(), SetAtom()
\par }\pard \fi-180\li540 {\i\f5 The project name has changed from WSNETC.VBX to WSANET.VBX
\par }{\f5 Reason for changes:
\par }\pard \fi-180\li720 {\f5 NetClnt.C/NetClnt.H now hold all of the NetClient control code
\par }{\f5 Ini.C/Ini.H now hold all of the Ini control }{\f5 code
\par }{\f5 WSANet.C/WSANet.H is the "glue" for the project.
\par }{\f5 Version.H holds all version information
\par }{\f5 WSANet.RC/WSANet.DEF hold the resources and definitions
\par }\pard \fi-180\li540 {\f5 Caused the programmer many headaches as he renamed everything ;)
\par }{\f5 Fixed WFinger/WSMTPC/VBTest to run under VB2.0 standard.
\par }{\f5 Added fully commented WFinger example code to the HLP file.
\par }\pard {\f5 
\par }{\b\f5 v1.06alpha to v1.07alpha
\par }\pard \fi-180\li540 {\f5 Added the }{\f5\uldb NetServer}{\v\f5 TOPIC_CONTROL_NETSERVER}{\f5  control. 
\par }{\f5 Fixed a nasty problem with v1.06alpha's use of ATOMs to store strings: all strings are now }{\f5 stored internally as Visual Basic strings (type HLSTR).
\par }{\f5 Changed the semantics of setting the Socket on the NetClient control so that NetServer's OnAccept(Socket, ...) could be handed over.
\par }{\f5 Fixed a potential problem with the FD_CLOSE message handler: it didn't "zero out" the Socket when it closed!
\par }{\f5 Dropped the VBTest client due to it's obvious inadequacies (and pointlessness)
\par }{\f5 Wrote WinWhois client.
\par }{\f5 Wrote WFingerD server.
\par }{\f5 Modified all VB3.0 examples to use a "standard" GUI appearance.
\par }{\f5 Shuffled the HLP f}{\f5 ile around. Topics have changed to include the control name along with the property context string.
\par }\pard {\b\f5 
\par }{\b\f5 v1.07alpha to v1.08alpha
\par }\pard \fi-180\li540 {\f5 Fixed a problem that caused WSAE_NOCONN errors.
\par }{\f5 Fixed a event firing problem.
\par }{\f5 Fixed the connection semantics
\par }{\f5 Added window position "memory" to VB3.0 samples
\par }{\f5 Wrote VB-SMTPD as a multi-connection state server which uses dynamic creation and destruction of NetClient controls.
\par }{\f5 Removed example code from the HLP file: the SAMPLES directory holds all source code, why keep 2 copies u}{\f5 p to date?
\par }{\f5 Setting Listen to LISTEN_DONTREUSE (2) will not open a server socket as SO_REUSEADDR.
\par }{\f5 Added the }{\f5\uldb Host}{\v\f5 NETCLIENT_PROPERTY_HOST}{\f5  property.
\par }{\f5 Fixed a Line property bug. Not only was it poorly coded before, I wonder what I was thinking at the time.
\par }{\f5 
\par }\pard {\b\f5 To-Do list:
\par }\pard \fi-180\li540 {\f5 - Make sure the binary transfer properties and functions are working
\par }{\f5     correctly.
\par }{\f5 - Make VC++ "sample" applications 
\par }{\f5 - Add OnGetHost() event, and AsyncHandle property (for non-blocking DNS
\par }{\f5     lookups)
\par }{\f5 - Add TCP/UDP and OOB switch.
\par }\pard \keepn {\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} PROPERTY_UNUSED}}{\plain \b\f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Unused Property}}{\plain 
\b\f5\lang1033  Unused Property
\par }\pard {\f5 
\par }\pard \li180 {\f5 
You, somehow, have managed to start up an older version of this HLP file with a newer version of WSANET.VBX. The context-sensitive help that you have selected is for a control property or event that this HLP file does not know about. Please check your sys
}{\f5 tem path for the older HLP file, and replace it with the new one. 
\par }{\f5 
\par }\pard {\f5 Have fun! 
\par }\pard \keepn {\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} TOPIC_CONTROL_INI}}{\plain \b\f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Ini Control}}{\plain 
\b\f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Ini Control;Controls}}{\plain \b\f5\lang1033  \{bml ini.bmp\} Ini Management Control
\par }\pard \keepn\tx1080\tx2160\tx3240\tx4320 {\f5\fs18\ul Properties}{\v\f5\fs18 POPUP_INI_PROPERTIES}{\f5\fs18 \tab }{\f5\fs18\ul Methods}{\v\f5\fs18 POPUP_INI_METHODS}{\f5\fs18 \tab }{\f5\fs18\ul Events}{\v\f5\fs18 POPUP_INI_EVENTS}{\f5\fs18 \tab }{
\f5\fs18\ul Errors}{\v\f5\fs18 POPUP_INI_ERRORS}{\f5\fs18 \tab }{\f5\fs18\uldb Examples}{\v\f5\fs18 T}{\v\f5\fs18 OPIC_INI_EXAMPLES}{\f5\fs18 
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 You can use the }{\b\f5 Ini}{\f5  control to access the Windows API calls that read to and write from .INI files. This control is invisible at run time, much like the timer control provided with Visual Basic.
\par }\pard {\f5 
\par }{\b\f5 File name
\par }\pard \li180 {\f5 WSANET.VBX
\par }\pard {\f5 
\par }{\b\f5 Object Type
\par }\pard \li180 {\f5 Ini
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 This control encapsulates the standard Windows API calls WritePrivateProfileString() and GetPrivateProfileString(). The }{\b\f5 Ini}{\f5 
 control makes it possible to read to and write from .INI files with little programming effort. The ratio}{\f5 nale behind including this control in the WSANET project was twofold; The }{\b\f5 Ini}{\f5 
 control is small, and almost every TCP/IP application requires some form of database or state information.
\par }\pard {\f5 
\par }{\b\f5 INI Format
\par }\pard \li180 {\f7\uldb Filename}{\v\f7 INI_PROPERTY_FILENAME}{\f7 :
\par }\pard \li360 {\f7 [}{\f7\uldb Section}{\v\f7 INI_PROPERTY_SECTION}{\f7 ]
\par }{\f7\uldb Entry}{\v\f7 INI_PROPERTY_ENTRY}{\f7  = }{\f7\uldb Value}{\v\f7 INI_PROPERTY_VALUE}{\f7 
\par }\pard {\f5 
\par }\pard \ri2880 {\f5 \page }{\b\fs16\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_INI_PROPERTIES}}{\b\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Ini Properties, Alphabetical list of}}{\b\fs16\up6 K
{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties}}{\b\f5  Properties
\par }\pard \li180\ri3600 {\f5 These are the properties for the }{\b\f5 Ini}{\f5  Control. Properties that apply }{\i\f5 only}{\f5  to this control, or that require special consideration when using it, are marked with an asterisk (*).
\par }\pard \ri3600 {\f5 
\par }\trowd \trgaph108\trleft552 \cellx1827\cellx3012\cellx4152\pard \intbl {\f5 CtlName\cell }{\f5 Index\cell }{\f5 Tag\cell }\pard \intbl {\f5 \row }\trowd \trgaph108\trleft552 \cellx1827\cellx3012\cellx4152\pard \intbl {\f5\uldb *Default}{\v\f5 
INI_PROPERTY_DEFAULT}{\f5 \cell }{\f5 Left\cell }{\f5 Top\cell }\pard \intbl {\f5 \row }\pard \intbl {\f5\uldb *Entry}{\v\f5 INI_PROPERTY_ENTRY}{\f5 \cell }{\f5 Parent\cell }{\f5\uldb *Value}{\v\f5 INI_PROPERTY_VALUE}{\f5 \cell }\pard \intbl {\f5 \row 
}\trowd \trgaph108\trleft552 \cellx1827\cellx3012\cellx4152\pard \intbl {\f5\uldb *Filename}{\v\f5 INI_PROPERTY_FILENAME}{\f5 \cell }{\f5\uldb *Section}{\v\f5 INI_PROPERTY_SECTION}{\f5 \cell }{\f5 \cell }\pard \intbl {\f5 \row }\pard 
\ri3600\tx1080\tx2160\tx3240\tx4320 {\f5 
\par }{\f5\uldb Value}{\v\f5 INI_PROPERTY_VALUE}{\f5  is the default property
\par }\pard \tx1080\tx2160\tx3240\tx4320 {\plain \b\f5\up6\lang1033 \page }{\fs16\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_INI_METHODS}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Methods}}{\plain 
\b\f5\up6\lang1033  }{\b\f5 Methods
\par }\pard \li180\tx1080\tx2160\tx3240\tx4320 {\f5 This current version of the Ini control supports no custom Methods.
\par }\pard \tx1080\tx2160\tx3240\tx4320 {\plain \b\f5\up6\lang1033 \page }{\fs16\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_INI_EVENTS}}{\plain \b\f5\up6\lang1033  }{\b\f5 Events
\par }\pard \li180\tx1080\tx2160\tx3240\tx4320 {\f5 This current version of the Ini control includes no standard or custom Events.
\par }\pard \tx1080\tx2160\tx3240\tx4320 {\plain \b\f5\up6\lang1033 \page }{\b\f5 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_INI_ERRORS}}{\b\f5  Errors
\par }\pard \li180\tx1080\tx2160\tx3240\tx4320 {\f5 This current version of the Ini control will ONLY return one error:
\par }\pard \li360\tx1080\tx2160\tx3240\tx4320 {\f5 ERR_OUTOFMEMOR}{\f5 Y - Error #7 - Out of memory
\par }\pard \tx1080\tx2160\tx3240\tx4320 {\plain \b\f5\lang1033 \page }{\f5 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} TOPIC_INI_EXAMPLES}}{\f5 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Ini Control Examples}}{\f5 K
{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Examples}}{\b\f5  Examples
\par }\pard \li180\tx1080\tx2160\tx3240\tx4320 {\f5 Here is a quick example of how to use the Ini control. The following is a fictitious .INI file:
\par }\pard \tx1080\tx2160\tx3240\tx4320 {\b\f5 
\par }\pard \li360\tx1080\tx2160\tx3240\tx4320 {\b\f7 \{sequoia.ini\}
\par }\pard \fi-180\li720\tx1080\tx2160\tx3240\tx4320 {\b\f7 [Sequoia]
\par }{\b\f7 MailFile=C:\\MAIL\\MAIL.TXT
\par }{\b\f7 CheckInterval=30
\par }{\b\f7 FullName=Ian C. Blenke
\par }{\b\f7 HomeAddress=iblenke@rhino.ess.harris.com
\par }{\b\f7 SMTPHostIP=130.41.1.251
\par }{\b\f7 TempDir=C:\\WINDOWS\\TEMP
\par }\pard \tx1080\tx2160\tx3240\tx4320 {\b\f5 
\par }\pard \li180\tx1080\tx2160\tx3240\tx4320 {\f5 Here are two quick subroutines that can access any entry in the above file:
\par }\pard \tx1080\tx2160\tx3240\tx4320 {\b\f5 
\par }\pard \fi-1260\li1440\tx1080\tx2160\tx3240\tx4320 {\b\f7\cf2 Function}{\b\f7  GetSequoiaEntry}{\b\f7\cf2 (}{\b\f7 sEntry }{\b\f7\cf2 As String,}{\b\f7  sDefault }{\b\f7\cf2 As String) As String
\par }\pard \li180\tx360\tx1080\tx2160\tx3240\tx4320 {\b\f7 \tab Ini.}{\b\f7\uldb Filename}{\b\v\f7 INI_PROPERTY_}{\b\v\f7 FILENAME}{\b\f7  }{\b\f7\cf2 =}{\b\f7  "sequoia.ini"
\par }{\b\f7 \tab Ini.}{\b\f7\uldb Section}{\b\v\f7 INI_PROPERTY_SECTION}{\b\f7  }{\b\f7\cf2 =}{\b\f7  "Sequoia"
\par }{\b\f7 \tab Ini.}{\b\f7\uldb Entry}{\b\v\f7 INI_PROPERTY_ENTRY}{\b\f7  }{\b\f7\cf2 =}{\b\f7  sEntry
\par }{\b\f7 \tab Ini.}{\b\f7\uldb Default}{\b\v\f7 INI_PROPERTY_DEFAULT}{\b\f7  }{\b\f7\cf2 =}{\b\f7  sDefault
\par }{\b\f7 \tab GetSequoiaEntry }{\b\f7\cf2 =}{\b\f7  Ini.}{\b\f7\uldb Value}{\b\v\f7 INI_PROPERTY_VALUE}{\b\f7 
\par }{\b\f7\cf2 End Function
\par }{\b\f7 
\par }{\b\f7\cf2 Sub}{\b\f7  SetSequoiaEntry}{\b\f7\cf2 (}{\b\f7 sEntry }{\b\f7\cf2 As String,}{\b\f7  sValue }{\b\f7\cf2 As String)
\par }{\b\f7 \tab Ini.}{\b\f7\uldb Filename}{\b\v\f7 INI_PROPERTY_FILENAME}{\b\f7  }{\b\f7\cf2 =}{\b\f7  "sequoia.ini"
\par }{\b\f7 \tab Ini.}{\b\f7\uldb Section}{\b\v\f7 INI_PROPERTY_SECTION}{\b\f7  }{\b\f7\cf2 =}{\b\f7  "Sequoia"
\par }{\b\f7 \tab Ini.}{\b\f7\uldb Entry}{\b\v\f7 INI_PROPERTY_ENTRY}{\b\f7  }{\b\f7\cf2 =}{\b\f7  sEntry
\par }{\b\f7 \tab Ini.}{\b\f7\uldb Value}{\b\v\f7 INI_PROPERTY_VALUE}{\b\f7  }{\b\f7\cf2 =}{\b\f7  sValue
\par }{\b\f7\cf2 End Sub
\par }\pard \tx360\tx1080\tx2160\tx3240\tx4320 {\b\f7 
\par }{\b\f5 Usage
\par }\pard \li180\tx360\tx1080\tx2160\tx3240\tx4320 {\f5 From here, you could set the HomeAddress }{\f5 entry to "iblenke@ic1d.harris.com" with the code:
\par }{\f7 
\par }\pard \li360\tx360\tx1080\tx2160\tx3240\tx4320 {\f7 SetSequoiaEntry("HomeAddress", "iblenke@ic1d.harris.com")
\par }\pard \li180\tx360\tx1080\tx2160\tx3240\tx4320 {\f5 
\par }{\f5 and you could read the HomeAddress entry with:
\par }{\f7 
\par }\pard \li360\tx360\tx1080\tx2160\tx3240\tx4320 {\f7 sSavedAddress = GetSequoiaEntry("HomeAddress", "")
\par }\pard \tx360\tx1080\tx2160\tx3240\tx4320 {\b\f5 
\par }{\b\f5 YES, It really }{\b\i\f5 is}{\b\f5  that easy!
\par }{\b\f5 
\par }\pard \brdrt\brdrs\brdrw30\brsp20 \brdrb\brdrs\brdrw30\brsp20 \tx360\tx1080\tx2160\tx3240\tx4320 {\b\f5 
Note: You DO NOT need to set the properties in any given order. As long as the appropriate properties are set before you use the Value property, you do not need to set them every time (they are stored internally as VB strings for each instance of the INI 
}{\b\f5 control}{\b\f5 ).
\par }\pard \tx1080\tx2160\tx3240\tx4320 {\plain \b\f5\lang1033 
\par }\pard \keepn\tx1080\tx2160\tx3240\tx4320 {\plain \b\f5\lang1033 \page }{\fs16 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} INI_PROPERTY_DEFAULT}}{\fs16 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Ini Default Property}}{
\fs16 k{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 k} Default;Properties}}{\plain \b\f5\lang1033  Default Property, Ini Control
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 This property is the }{\b\f5 Default}{\f5  value returned through the }{\f5\uldb Value}{\v\f5 INI_PROPERTY_VALUE}{\f5  property if no }{\f5\uldb Entry}{\v\f5 INI_PROPERTY_ENTRY}{\f5  in [}{\f5\uldb Section}{\v\f5 INI_PROPERTY_SECTION}{
\f5 ] of a }{\f5\uldb Filename}{\v\f5 INI_PROPERTY_FILENAME}{\f5  can be found.
\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5 Ini}{\f5  .}{\b\f5 Default}{\f5 [}{\i\f5 = value$}{\f5 ]
\par }{\f5 [}{\i\f5 value$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  Ini}{\f5 .}{\b\f5 Default}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pIni->}{\b\f5 GetStrProperty("Default")}{\f5 
\par }{\f5 pIni->}{\b\f5 SetStrProperty("Default",}{\i\f5  eol$}{\b\f5 )
\par }{\b\f5 
\par }\pard {\b\f5 Remarks
\par }\pard \li180 {\f5 This property corresponds to the Default argument to a GetPrivateProfileStrin}{\f5 g() call.
\par }\pard {\b\f5 
\par }{\b\f5 VB Errors
\par }\pard \fi-2700\li2880\tx2610\tx2880 {\f5 ERR_OUTOFMEMORY (7)\tab -\tab When }{\b\f5 Default}{\f5  is read, and a response string could not be created.
\par }\pard \li180 {\f5 
\par }\pard {\b\f5 Data Type
\par }\pard \li180 {\b\f5 String}{\f5  (HSZ)
\par }{\f5 
\par }\pard {\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard \keepn\tx1080\tx2160\tx3240\tx4320 {\plain \b\f5\up6\lang1033 \page }{\fs16 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} INI_PROPERTY_ENTRY}}{\fs16 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Ini Entry Property}}{
\fs16 k{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 k} Entry;Properties}}{\plain \b\f5\lang1033  Entry Property, Ini Control
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 This property is the }{\b\f5 Entry}{\f5  line in the [}{\f5\uldb Section}{\v\f5 INI_PROPERTY_SECTION}{\f5 ] of a }{\f5\uldb Filename}{\v\f5 INI_PROPERTY_FILENAME}{\f5  that you must set in order to use the }{\f5\uldb Value}{\v\f5 
INI_PROPERTY_VALUE}{\f5  property. 
\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5 Ini}{\f5  .}{\b\f5 Entry}{\f5 [}{\i\f5 = entry$}{\f5 ]
\par }{\f5 [}{\i\f5 entry$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  Ini}{\f5 .}{\b\f5 Entry}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pIni->}{\b\f5 GetStrProperty("Entry")}{\f5 
\par }{\f5 pIn}{\f5 i->}{\b\f5 SetStrProperty("Entry",}{\i\f5  entry$}{\b\f5 )
\par }{\b\f5 
\par }\pard {\b\f5 Remarks
\par }\pard \li180 {\f5 This property corresponds to the Entry argument given to both the GetPrivateProfileString() and WritePrivateProfileString() calls.
\par }{\f5 
\par }{\f5 If the Entry in a [Section] of the .INI file does not exist, when }{\f5\uldb Value}{\v\f5 INI_PROPERTY_VALUE}{\f5  is set, the Entry will be created.
\par }{\f5 
\par }{\f5 If the Entry in a [Section] in the .INI file does not exist, when }{\f5\uldb Value}{\v\f5 INI_PROPERTY_VALUE}{\f5  is read, the }{\f5\uldb Default}{\v\f5 INI_PROPERTY_DEFAULT}{\f5  value is returned.
\par }\pard {\b\f5 
\par }{\b\f5 VB Errors
\par }\pard \fi-2700\li2880\tx2610\tx2880 {\f5 ERR_OUTOFMEMORY (7)\tab -\tab When }{\b\f5 Entry}{\f5  is rea}{\f5 d, and a response string could not be created.
\par }\pard \li180 {\f5 
\par }\pard {\b\f5 Data Type
\par }\pard \li180 {\b\f5 String}{\f5  (HSZ)
\par }{\f5 
\par }\pard {\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard \keepn\tx1080\tx2160\tx3240\tx4320 {\plain \b\f5\up6\lang1033 \page }{\fs16 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} INI_PROPERTY_FILENAME}}{\fs16 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Ini Filename Prope
rty}}{\fs16 k{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 k} Filename;Properties}}{\plain \b\f5\lang1033  Filename Property, Ini Control
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 This property is the }{\b\f5 Filename}{\f5  of the .INI file from which to extract a }{\f5\uldb Value}{\v\f5 INI_PROPERTY_VALUE}{\f5  from a }{\f5\uldb Entry}{\v\f5 INI_PROPERTY_ENTRY}{\f5  in a [}{\f5\uldb Section}{\v\f5 
INI_PROPERTY_SECTION}{\f5 ] 
\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5 Ini}{\f5  .}{\b\f5 Filename}{\f5 [}{\i\f5 = ini_filename$}{\f5 ]
\par }{\f5 [}{\i\f5 ini_filename$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  Ini}{\f5 .}{\b\f5 Filename}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pIni->}{\b\f5 GetStrProperty("Filename")}{\f5 
\par }{\f5 pIni->}{\b\f5 SetStrProperty("Filename",}{\i\f5  ini_filename$}{\b\f5 )
\par }{\b\f5 
\par }\pard {\b\f5 Remark}{\b\f5 s
\par }\pard \li180 {\f5 This property corresponds to the }{\b\f5 Filename}{\f5 
 argument given to both the GetPrivateProfileString() and WritePrivateProfileString() calls. You do NOT have to use a full path name: in fact, it is better to use just the base .INI filename in order to allow users to keep their .INI files wherever they w
}{\f5 ish in their path. The Windows API calls take care of the underlying searches, you merely have to set this property to the name of an .INI file somewhere in the system path.
\par }{\f5 
\par }{\f5 If the .INI file corresponding to }{\b\f5 Fi}{\b\f5 lename}{\f5  does not exist, when }{\f5\uldb Value}{\v\f5 INI_PROPERTY_VALUE}{\f5  is set, the .INI file will be created.
\par }{\f5 
\par }{\f5 If the .INI file corresponding to }{\b\f5 Filename}{\f5  does not exist, when }{\f5\uldb Value}{\v\f5 INI_PROPERTY_VALUE}{\f5  is read, the }{\f5\uldb Default}{\v\f5 INI_PROPERTY_DEFAULT}{\f5  value is returned.
\par }{\f5 
\par }\pard {\b\f5 VB Errors
\par }\pard \fi-2700\li2880\tx2610\tx2880 {\f5 ERR_OUTOFMEMORY (7)\tab -\tab When }{\b\f5 Filename}{\f5  is read, and a response string could not be created.
\par }\pard \li180 {\f5 
\par }\pard {\b\f5 Data Type
\par }\pard \li180 {\b\f5 String}{\f5  (HSZ)
\par }{\f5 
\par }\pard {\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard \fi-7\keepn\tx1080\tx2160\tx3240\tx4320 {\plain \b\f5\up6\lang1033 \page }{\fs16 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} INI_PROPERTY_SECTION}}{\fs16 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 Ini Section Property}}{\fs16 k{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 k} Section;Properties}}{\plain \b\f5\lang1033  Section Property, Ini Control
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 This property is the }{\f5\uldb Section}{\v\f5 INI_PROPERTY_SECTION}{\f5  in a .INI }{\f5\uldb Filename}{\v\f5 I}{\v\f5 NI_PROPERTY_FILENAME}{\f5  from which to extract a }{\f5\uldb Value}{\v\f5 INI_PROPERTY_VALUE}{\f5  from a }{
\f5\uldb Entry}{\v\f5 INI_PROPERTY_ENTRY}{\f5 .
\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5 Ini}{\f5  .}{\b\f5 Section}{\f5 [}{\i\f5 = section$}{\f5 ]
\par }{\f5 [}{\i\f5 section$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  Ini}{\f5 .}{\b\f5 Section}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pIni->}{\b\f5 GetStrProperty("Section")}{\f5 
\par }{\f5 pIni->}{\b\f5 SetStrProperty("Section",}{\i\f5  section$}{\b\f5 )
\par }{\b\f5 
\par }\pard {\b\f5 Remarks
\par }\pard \li180 {\f5 This property corresponds to the }{\b\f5 Section}{\f5  argument given to both the GetPrivateProfileString() and WritePrivateProfileString() calls.
\par }{\f5 
\par }{\f5 If the [Section] in an .INI file corresponding to the }{\b\f5 Section}{\f5  property does not exist, w}{\f5 hen }{\f5\uldb Value}{\v\f5 INI_PROPERTY_VALUE}{\f5  is set, the [Section] will be created.
\par }{\f5 
\par }{\f5 If the [Section] in an .INI file corresponding to the }{\b\f5 Section}{\f5  property does not exist, when }{\f5\uldb Value}{\v\f5 INI_PROPERTY_VALUE}{\f5  is read, the }{\f5\uldb Default}{\v\f5 INI_PROPERTY_DEFAULT}{\f5  value is returned.
\par }\pard {\b\f5 
\par }{\b\f5 VB Errors
\par }\pard \fi-2700\li2880\tx2610\tx2880 {\f5 ERR_OUTOFMEMORY (7)\tab -\tab When }{\b\f5 Section}{\f5  is read, and a response string could not be created.
\par }\pard \li180 {\f5 
\par }\pard {\b\f5 Data Type
\par }\pard \li180 {\b\f5 String}{\f5  (HSZ)
\par }{\f5 
\par }\pard {\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard \keepn\tx1080\tx2160\tx3240\tx4320 {\plain \b\f5\up6\lang1033 \page }{\fs16 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} INI_PROPERTY_VALUE}}{\fs16 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Ini Value Property}}{
\fs16 k{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 k} Value;Properties}}{\plain \b\f5\lang1033  Value Property, Ini Control
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 This property is the actual }{\b\f5 Value}{\f5  that is set as an }{\f5\uldb Entry}{\v\f5 INI_PROPER}{\v\f5 TY_ENTRY}{\f5  in a }{\f5\uldb Section}{\v\f5 INI_PROPERTY_SECTION}{\f5  in an .INI }{\f5\uldb Filename}{\v\f5 
INI_PROPERTY_FILENAME}{\f5 .
\par }{\f5 This property is the default property of the }{\b\f5 Ini}{\f5  control.
\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5 Ini}{\f5  .}{\b\f5 Value}{\f5 [}{\i\f5 = value$}{\f5 ]
\par }{\f5 [}{\i\f5 value$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  Ini}{\f5 .}{\b\f5 Value}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pIni->}{\b\f5 GetStrProperty("Value")}{\f5 
\par }{\f5 pIni->}{\b\f5 SetStrProperty("Value",}{\i\f5  value$}{\b\f5 )
\par }{\b\f5 
\par }\pard {\b\f5 Remarks
\par }\pard \li180 {\f5 This property corresponds to the actual buffer or string argument given to both the GetPrivateProfileString() and WritePrivateProfileString() calls.
\par }{\f5 
\par }{\f5 If the }{\f5\uldb Filename}{\v\f5 INI_PROPERTY_FILENAME}{\f5 , }{\f5\uldb Sectio}{\f5\uldb n}{\v\f5 INI_PROPERTY_SECTION}{\f5 , or }{\f5\uldb Entry}{\v\f5 INI_PROPERTY_ENTRY}{\f5  do not exist, the }{\b\f5 Value}{\f5 
 property will return what is in the }{\f5\uldb Default}{\v\f5 INI_PROPERTY_DEFAULT}{\f5  property when read.
\par }{\f5 
\par }{\f5 If the }{\f5\uldb Filename}{\v\f5 INI_PROPERTY_FILENAME}{\f5 , }{\f5\uldb Section}{\v\f5 INI_PROPERTY_SECTION}{\f5 , or }{\f5\uldb Entry}{\v\f5 INI_PROPERTY_ENTRY}{\f5  do not exist, and the }{\b\f5 Value}{\f5 
 property is set, the appropriate fields in the .INI file will be created.
\par }\pard {\b\f5 
\par }{\b\f5 VB Errors
\par }\pard \fi-2700\li2880\tx2610\tx2880 {\f5 ERR_OUTOFMEMORY (7)\tab -\tab When }{\b\f5 Value}{\f5  is read, and a response string could not be created.
\par }\pard \li180 {\f5 
\par }\pard {\b\f5 Data Type
\par }\pard \li180 {\b\f5 String}{\f5  (HSZ)
\par }{\f5 
\par }\pard {\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard \keepn\tx1080\tx2160\tx3240\tx4320 {\plain \b\f5\up6\lang1033 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} TOPIC_CONTROL_NETSERVER}}{\fs16\up6 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} NetServer Control}}
{\plain \b\f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetServer Control;Controls}}{\plain \b\f5\lang1033  }{\plain \b\f5\lang1033 \{bml netsrvr.bmp\} WinSock Network Server Control 
\par }{\f5\fs18\ul Properties}{\v\f5\fs18 POPUP_NETSERVER_PROPERTIES}{\f5\fs18 \tab }{\f5\fs18\ul Methods}{\v\f5\fs18 POPUP_NETSERVER_METHODS}{\f5\fs18 \tab }{\f5\fs18\ul Events}{\v\f5\fs18 POPUP_NETSERVER_EVENTS}{\f5\fs18 \tab }{\f5\fs18\ul Errors}{
\v\f5\fs18 POPUP_NETSERVER_ERRORS}{\f5\fs18 \tab }{\f5\fs18\ul Examples}{\v\f5\fs18 POPUP_NETSERVER_EXAMPLES}{\f5\fs18 
\par }\pard {\f5 
\par }{\b\f5 Description
\par }\pard \li180 {\f5 You can use the NetServer control to access the }{\f5\uldb Windows Sockets}{\v\f5 TOPIC_SOCKET}{\f5  v1.1 server calls. This control is invisible at run time, much like the timer control provided with Visual Basic.
\par }\pard {\f5 
\par }{\b\f5 File name
\par }\pard \li180 {\f5 WSANET.VBX
\par }\pard {\f5 
\par }{\b\f5 Object Type
\par }\pard \li180 {\f5 NetServer
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 The }{\b\f5 NetServer}{\f5  control uses functi}{\f5 
onality provided by a vendor specific version of WINSOCK.DLL that is provided with your TCP/IP protocol kernel. With this control, you can export any TCP service that you want for other TCP/IP hosts to use. This control supports the TCP server side paradi
}{\f5 gm only, you must use the }{\f5\uldb NetClient}{\v\f5 TOPIC_CONTROL_NETCLIENT}{\f5  control to initiate a client connection to a remote host. You must also use the }{\f5\uldb NetClient}{\v\f5 TOPIC_CONTROL_NETCLIENT}{\f5 
 control to actually talk to any remote host that the }{\b\f5 NetServer}{\f5  control accept()s. A U}{\f5 DP server cannot yet be written with the current version of this control.
\par }{\f5 
\par }\pard \li180\brdrt\brdrs\brdrw15\brsp20 \brdrb\brdrs\brdrw15\brsp20 {\b\f5 Distribution Note}{\f5 \tab When you create and distribute applications written with the NetServer control, you should copy the file RELEASE.VBX as WSANET.VBX into your user's \\
SYSTEM subdirectory or otherwise in the system path. The WSANET.VBX file distributed with the project is }{\f5 a debugging version (and thus requires DBWIN or OX.SYS in order to work correctly).
\par }\pard \ri2880 {\b\fs16\up6 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETSERVER_PROPERTIES}}{\b\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetServer Properties, Alphabetical list of}}{
\b\fs16\up6 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties}}{\b\f5  Properties
\par }\pard \li180\ri3600 {\f5 These are the properties for the }{\b\f5 NetServer}{\f5  control. Propertie}{\f5 s that apply }{\i\f5 only}{\f5  to this control, or that require special consideration when using it, are marked with an asterisk (*).
\par }{\f5 
\par }\trowd \trgaph108\trleft582 \cellx2637\cellx4107\cellx5832\cellx7092\pard \li180\intbl\tx1080\tx2160\tx3240\tx4320 {\f5\uldb *About}{\v\f5 PROPERTY_ABOUT}{\f5 \cell }{\f5 hWnd\cell }{\f5\uldb *LocalService}{\v\f5 NETSERVER_PROPERTY_LOCALSERVICE}{\f5 
\cell }{\f5 Top\cell }\pard \intbl {\f5 \row }\trowd \trgaph108\trleft582 \cellx2637\cellx4107\cellx5832\cellx7092\pard \li180\intbl\tx1080\tx2160\tx3240\tx4320 {\f5 CtlName(Name)\cell }{\f5 Index\cell }{\f5 Parent\cell }{\f5\uldb *Version}{\v\f5 
NETSERVER_PROPERTY_VERSION}{\f5 \cell }\pard \intbl {\f5 \row }\pard \li180\intbl\tx1080\tx2160\tx3240\tx4320 {\f5\uldb *Debug}{\v\f5 NETSERVER_PROPERTY_DEBUG}{\f5 \cell }{\f5 Left\cell }{\f5\uldb *QueueSize}{\v\f5 NETSERVER_PROPERTY_QUEUESIZE}{\f5 \cell 
}{\f5 \cell }\pard \intbl {\f5 \row }\pard \li180\intbl\tx1080\tx2160\tx3240\tx4320 {\f5\uldb *ErrorMessage}{\v\f5 NETSERVER_PROPERTY_ERRORMESSAGE}{\f5 \cell }{\f5\uldb *Listen}{\v\f5 NETSERVER_PROPERTY_LISTEN}{\f5 \cell }{\f5\uldb *Socket}{\v\f5 
NETSERVER_PROPERTY_SOCKET}{\f5 \cell }{\f5 \cell }\pard \intbl {\f5 \row }\trowd \trgaph108\trleft582 \cellx2637\cellx4107\cellx5832\cellx7092\pard \li180\intbl\tx1080\tx2160\tx3240\tx4320 {\f5\uldb *ErrorNumber}{\v\f5 NETSERVER_PROPERTY_ERRORNUM}{\v\f5 
BER}{\f5 \cell }{\f5\uldb *LocalPort}{\v\f5 NETSERVER_PROPERTY_LOCALPORT}{\f5 \cell }{\f5 Tag\cell }{\f5 \cell }\pard \intbl {\f5 \row }\pard \li180\ri3600 {\f5 
\par }{\f5\uldb Listen}{\v\f5 NETSERVER_PROPERTY_LISTEN}{\f5  is the default property
\par }\pard \tx1080\tx2160\tx3240\tx4320 {\plain \b\f5\up6\lang1033 \page }{\fs16\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETSERVER_METHODS}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Methods}}
{\plain \b\f5\up6\lang1033  }{\b\f5 Methods
\par }\pard \li180\tx1080\tx2160\tx3240\tx4320 {\f5 This current version of the NetServer control supports no custom Methods.
\par }\pard \tx1080\tx2160\tx3240\tx4320 {\plain \b\f5\up6\lang1033 \page }{\fs16\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETSERVER_EVENTS}}{\plain \b\f5\up6\lang1033  }{\b\f5 Events
\par }\pard \li180\tx1080\tx2160\tx3240\tx4320 {\f5 The NetServer control supports 2 events:
\par }{\f5 
\par }\trowd \trgaph108\trleft582 \cellx2457\cellx4272\pard \li180\intbl\tx1080\tx2160\tx3240\tx4320 {\f5\uldb OnAccept()}{\v\f5 NETSERVER_EVENT_ONACCEPT}{\f5 \cell }{\f5\uldb OnError()}{\v\f5 NETSERVER_EVENT_ONERROR}{\f5 \cell }\pard \intbl {\f5 \row }\pard 
\tx1080\tx2160\tx3240\tx4320 {\plain \b\f5\up6\lang1033 \page }{\b\f5 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETSERVER_ERRORS}}{\b\f5  Errors
\par }\pard \li180\tx1080\tx2160\tx3240\tx4320 {\f5 This current version of the NetServer control returns these errors:
\par }{\f5 
\par }\trowd \trgaph108\trleft582 \cellx4452\cellx5697\pard \li360\intbl\tx1080\tx2160\tx3240\tx4320 {\f5 VBERR_INVALIDPROPERTYVALUE\cell }{\f5 380\cell }\pard \intbl {\f5 \row }\trowd \trgaph108\trleft582 \cellx4452\cellx5697\pard 
\li360\intbl\tx1080\tx2160\tx3240\tx4320 {\f5 VBERR_READONLY\cell }{\f5 383\cell }\pard \intbl {\f5 \row }\pard \li360\intbl\tx1080\tx2160\tx3240\tx4320 {\f5 VBERR_WRITEONLY\cell }{\f5 394\cell }\pard \intbl {\f5 \row }\pard 
\li360\intbl\tx1080\tx2160\tx3240\tx4320 {\f5 WSAERR_AlreadyConn\cell }{\f5 20001\cell }\pard \intbl {\f5 \row }\trowd \trgaph108\trleft582 \cellx4452\cellx5697\pard \li360\intbl\tx1080\tx2160\tx3240\tx4320 {\f5 WSAERR_NotConn\cell }{\f5 20005\cell 
}\pard \intbl {\f5 \row }\pard \li180\tx1080\tx2160\tx3240\tx4320 {\f5 
\par }{\f5 You can include the "constants" file WSANET.TXT to get these }{\f7\cf2 Global Const}{\f5 's.
\par }\pard \tx1080\tx2160\tx3240\tx4320 {\f5 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETSERVER_EXAMPLES}}{\f5 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetServer Control Examples}}{\f5 K{\footnote 
\pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Examples}}{\b\f5  Examples
\par }\pard \li180\tx1080\tx2160\tx3240\tx4320 {\f5 The NetServer control currently has 2 sample applications:
\par }{\f5 
\par }\pard \fi-1620\li1980\tx1080\tx1800\tx2160\tx3240\tx4320 {\f5 WFingerd\tab A simple Finger Daemon/Server that can accept/handle 1 connection at a time.
\par }{\f5 VB-SMTPD\tab A complex SMTP Daemon/Server that can accept/handle multiple connections at a time, each connection contains it's own "state".
\par }\pard \keepn {\f5 \page }{\plain \b\f5\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETSERVER_PROPERTY_DEBUG}}{\plain \b\f5\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetServer Debug Property}}
{\plain \b\f5\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;Debug}}{\plain \b\f5\lang1033  Debug Property, NetServer Control
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 Sets or returns the current state of the SO_}{\f5 DEBUG socket option on the main listen()ing socket.
\par }\pard {\f5  
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetServer}{\f5 .}{\b\f5 Debug }{\f5 [}{\i\f5 = bool%}{\f5 ]
\par }{\f5 [}{\i\f5 bool%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetServer}{\f5 .}{\b\f5 Debug}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetServer->}{\b\f5 GetNumProperty("Debug")}{\f5 
\par }{\f5 pNetServer->}{\b\f5 SetNumProperty("Debug",}{\i\f5 bool%}{\b\f5 )
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 This property reflects the current socket level debugging state of the main listening socket.
\par }{\f5 
\par }{\f5 When setting this property, if }{\f5\uldb Listen}{\v\f5 NETSERVER_PROPERTY_LISTEN}{\f5  is }{\f5\cf2 False}{\f5 , WSAERROR_NotConn (20005) is set by the control, and no action is taken. If }{\f5\uldb Listen}{\v\f5 NETSERVER_PROP}{\v\f5 ERTY_LISTEN}{
\f5  is True, setsockopt() is called, or the }{\f5\uldb ErrorNumber}{\v\f5 NETSERVER_PROPERTY_ERRORNUMBER}{\f5  property is set to the appropriate }{\f5\uldb WinSock error}{\v\f5 TOPIC_WINSOCKERRORS}{\f5 .
\par }{\f5 
\par }{\f5 When reading this property, if }{\f5\uldb Listen}{\v\f5 NETSERVER_PROPERTY_LISTEN}{\f5  is }{\f5\cf2 False}{\f5 , }{\f5\cf2 False}{\f5  is ALWAYS returned. If }{\f5\uldb Listen}{\v\f5 NETSERVER_PROPERTY_LISTEN}{\f5  is }{\f5\cf2 True}{\f5 
, getsockopt() is called, or the }{\f5\uldb ErrorNumber}{\v\f5 NETSERVER_PROPERTY_ERRORNUMBER}{\f5  property is set to the appropriate }{\f5\uldb WinSock error}{\v\f5 TOPIC_WINSOCKERRORS}{\f5 .
\par }{\f5 
\par }{\f5 The debugging information supplied by most WinSock vendors}{\f5 
 is in the form of OutputDebugString() calls. In order to view this debugging information, you will need the DBWIN application from the 3.1 SDK, or an equivalent application that hooks the debugging output. Most commercial packages do NOT include any debu
}{\f5 gging information, or support the SO_DEBUG socket option.
\par }\pard {\f5 
\par }{\b\f5 WinSock calls
\par }\pard \li180 {\f5 getsockopt(), setsockopt()
\par }\pard {\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 Integer}{\f5  (Boolean)
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard {\f5 
\par }\pard \keepn {\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETSERVER_PROPERTY_LISTEN}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetServer Listen Property}}{\fs16\up6 K
{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;Listen}}{\plain \b\f5\up6\lang1033  }{\plain \b\f5\lang1033 Listen Property, NetServer Control
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 Reports or sets the current connection stat}{\f5 us of the associated socket.
\par }\pard {\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetServer}{\f5 .}{\b\f5 Listen}{\f5 [}{\i\f5 = state%}{\f5 ]
\par }{\f5 [}{\i\f5 state%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetServer}{\f5 .}{\b\f5 Listen}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetServer->}{\b\f5 GetNumProperty("Listen")}{\f5 
\par }{\f5 pNetServer->}{\b\f5 SetNumProperty("Listen",}{\f5  }{\i\f5 state}{\b\f5 )
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 Setting this property to }{\f5\cf2 True}{\f5  (-1 or <> 0 and <> 2) will cause the control to start listening to the specified }{\f5\uldb LocalPort}{\v\f5 NETSERVER_PROPERTY_LOCALPORT}{\f5 
. The port is allocated with SO_REUSEADDR, so be sure to remind the user that your daemon/server WILL take over the corresponding port.}{\f5  This "feature" was created just in case the application inadvertantly crashes without closing the Socket.
\par }{\f5 
\par }{\f5 Setting this property to LISTEN_DONTREUSE (2) will cause the control to start listening to the specified }{\f5\uldb LocalPort}{\v\f5 NETSERVER_PROPERTY_LOCALPORT}{\f5 
, but will NOT set the SO_REUSEADDR socket option. This is intended for programs that do not wish to take over the port of a service that is already handled by another application. 
\par }{\f5 
\par }{\f5 Setting this property to }{\f5\cf2 False}{\f5  (0) will cause the control to stop listening}{\f5  for any further incoming connections via the closesocket() call.
\par }\pard {\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180 {\f5 socket(), WSAAsyncSelect(), bind(), listen(), closesocket()
\par }\pard {\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 Integer
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard \keepn {\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETSERVER_PROPERTY_ERRORMESSAGE}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetServer ErrorMessage Property}}{
\fs16\up6 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;ErrorMessage}}{\plain \b\f5\lang1033  ErrorMessage Property, NetServer Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETSERVER_SEEALSO_ERRORMESSAGE}{\f5\fs18 
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 Returns the error message for the }{\f5\uldb ErrorNumber}{\v\f5 NETSERVER_PROPERTY_ERRORNUMBER}{\f5  property.
\par }\pard {\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 message$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetServer}{\b\f5 .ErrorMessage}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetServer->}{\b\f5 GetStrProperty("ErrorMessage")}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Remarks}{\b\f5 
\par }\pard \li180 {\f5 This property corresponds to the }{\f5\uldb ErrorNumber}{\v\f5 NETSERVER_PROPERTY_ERRORNUMBER}{\f5  property. The VBX's resource string table is used to get the corresponding error message.
\par }\pard {\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180 {\f5 None.
\par }\pard {\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 String }{\f5 (HSZ)
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard {\b\f5\fs22 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETSERVER_SEEALSO_ERRORMESSAGE}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb ErrorNumber}{\v\f5 NETSERVER_PROPERTY_ERRORNUMBER}{\f5 
\par }{\f5\uldb OnError()}{\v\f5 NETSERVER_EVENT_ONERROR}{\f5 
\par }\pard \keepn {\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETSERVER_PROPERTY_ERRORNUMBER}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetServer ErrorNumber Property}}{
\fs16\up6 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;Errors;ErrorNumber}}{\plain \b\f5\lang1033  ErrorNumber Property, NetServer Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETSERVER_SEEALSO_ERRORNUMBER}{\f5\fs18 
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 Reports any error condition from the NetServer control.
\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form }{\i\f5 .}{\f5 ]}{\i\f5  NetServer}{\f5 .}{\b\f5 ErrorNumber }{\f5 [}{\i\f5 = status%}{\f5 ]
\par }{\f5 [}{\i\f5 status%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetServer}{\f5 .}{\b\f5 ErrorNumber}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetServer->}{\b\f5 GetNumProperty("ErrorNumber")}{\f5 
\par }{\f5 pNetServer->}{\b\f5 SetNumProperty("ErrorNumber",}{\i\f5 status%}{\b\f5 )
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 This property returns any error at the Windows Sockets level. You can set this property at any time in your application. The }{\f5\uldb ErrorMessage}{\v\f5 NETSERVER_PROPERTY_ERRORMESSAGE}{\f5 
 property returns strings based upon the value stored in this property.
\par }{\f5 
\par }{\f5 Please consult }{\f5\uldb WinSock Errors}{\v\f5 TOPIC_WINSOCKERRORS}{\f5  for more informatio}{\f5 n on WinSock specific errors.
\par }\pard {\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180 {\f5 WSAGetLastError() is called to get the error status whenever a WinSock function returns SOCKET_ERROR. Therefore, this property does not call any WinSock related functions; }{\b\f5 ErrorNumbe}{\f5 r is set as the error occurs.
\par }\pard {\f5 
\par }{\b\f5 Data Type
\par }\pard \li180\tx3510 {\b\f5 Integer
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard {\b\f5\fs22 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETSERVER_SEEALSO_ERRORNUMBER}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb ErrorMessage}{\v\f5 NETSERVER_PROPERTY_ERRORMESSAGE}{\f5 
\par }{\f5\uldb OnError()}{\v\f5 NETSERVER_EVENT_ONERROR}{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETSERVER_PROPERTY_LOCALPORT}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetServer LocalPort Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;LocalPort}}{\plain \b\f5\lang1033  LocalPort Property, NetServer Control
\par }\pard \keepn\tx1440\tx3510 {\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETSERVER_SEEALSO_LOCALPORT}{\f5\fs18 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 The }{\b\f5 LocalPort}{\f5  pr}{\f5 operty is used to set the local port number for the NetServer control to listen() to for an incoming TCP connection.
\par }\pard \tx3510 {\b\f5 
\par }\pard {\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetServer}{\f5 .}{\b\f5 LocalPort}{\f5 [}{\i\f5 = port%}{\f5 ]
\par }{\f5 [}{\i\f5 port%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetServer}{\f5 .}{\b\f5 LocalPort}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetServer->}{\b\f5 GetNumProperty("LocalPort")}{\f5 
\par }{\f5 pNetServer->}{\b\f5 SetNumProperty("LocalPort",}{\f5  }{\i\f5 port%}{\b\f5 )
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 This property denotes the local port that is used to bind() a listen()ing NetServer Socket to. Any port number from 1 to 32767 can be used, altough the ports between 1 and 1024 are usua}{\f5 
lly reserved for "restricted port" TCP services.
\par }{\f5 
\par }{\f5 The idea of }{\i\f5 restricted}{\f5  ports stems from }{\f5\ul BSD}{\v\f5 POPUP_BSD}{\f5 
 Unix, where an application must run as root in order to bind() to a port below 1023. These ports are the well known Unix services such as FTP, SMTP, Finger, and so on.
\par }\pard \tx3510 {\b\f5 
\par }\pard \li180\brdrt\brdrs\brdrw30\brsp20 \brdrb\brdrs\brdrw30\brsp20 \tx3510 {\b\f5 Note: }{\f5 You MUST set this property before using the }{\f5\uldb Listen}{\v\f5 NETSERVER_PROPERTY_LISTEN}{\f5  property.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180\tx3510 {\f5 This property is used at listen() time. See the }{\f5\uldb Listen}{\v\f5 NETSERVER_PROPERTY_LISTEN}{\f5  property for more information.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180\tx3510 {\b\f5 I}{\b\f5 nteger
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Scope
\par }\pard \li180\tx3510 {\f5 VB1.0+/VC++
\par }\pard {\b\f5\fs22 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETSERVER_SEEALSO_LOCALPORT}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb LocalService}{\v\f5 NETSERVER_PROPERTY_LOCALSERVICE}{\f5\uldb 
\par }{\f5\uldb Listen}{\v\f5 NETSERVER_PROPERTY_LISTEN}{\f5 
\par }{\f5\uldb QueueSize}{\v\f5 NETSERVER_PROPERTY_QUEUESIZE}{\f5\uldb 
\par }\pard \keepn\tx3510 {\fs16\up6 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETSERVER_PROPERTY_LOCALSERVICE}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetServer LocalService Property}}{\fs16\up6 K
{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;LocalService}}{\b\f5  }{\plain \b\f5\lang1033 LocalService Property, NetServer Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETSERVER_SEEALSO_LOCALSERVICE}{\b\f5 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 
This property allows an application to use the getservbyXXX() database services. By using this property, you allow the user to merely modify their TCP/IP's stack in order to use the port that your application uses for the local client port binding}{\f5 . 

\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5 NetServer}{\f5  .}{\b\f5 LocalService}{\f5 [}{\i\f5 = name$}{\f5 ]
\par }{\f5 [}{\i\f5 name$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetServer}{\f5 .}{\b\f5 LocalService}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetServer->}{\b\f5 GetStrProperty("LocalService")}{\f5 
\par }{\f5 pNetServer->}{\b\f5 SetStrProperty("LocalService",}{\i\f5  name$}{\b\f5 )
\par }\pard {\f5 
\par }\pard \tx3510 {\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 This property is used instead of the }{\f5\uldb LocalPort}{\v\f5 NETSERVER_PROPERTY_LOCALPORT}{\f5  property in order to set the }{\i\f5 Service name}{\f5  for the local port.
\par }\pard \tx3510 {\b\f5 
\par }\pard \li180\tx3510 {\f5 When set, this property calls getservbyname() and sets }{\f5\uldb LocalPort}{\v\f5 NETSERVER_PROPERTY_LOCALPORT}{\f5  to the corresponding integer port number.
\par }{\f5 
\par }{\f5 When you }{\f5 get this properties' value it calls getservbyport() and returns the appropriate }{\i\f5 Service name}{\f5  for the }{\f5\uldb LocalPort}{\v\f5 NETSERVER_PROPERTY_LOCALPORT}{\f5  property.
\par }{\f5 
\par }{\f5 When you either set or get this property, check it for an empty string (""). When the }{\i\f5 Service}{\f5  database lookup fails with a NULL pointer, this property will be set to "", and }{\f5\uldb LocalPort}{\v\f5 NETSERVER_PROPERTY_LOCALPORT}{
\f5  will be set to 0.
\par }{\f5 
\par }{\f5 The only real reason for using this property is to use reserved ports. You should use this call instead of the }{\f5\uldb LocalPort}{\v\f5 NETSERV}{\v\f5 ER_PROPERTY_LOCALPORT}{\f5 
 property - not use a hard set value. This will allow your users to merely change their HOSTS file (or equivalent) to change the port that the daemon runs on. You may also decide to allow the user to set a desired port via your own application's setup dia
}{\f5 log instead of their HOSTS file.
\par }{\f5 
\par }{\f5 Some Vendors' WinSock.DLLs will appropriately block if the "Services" database is not held locally (i.e. Sun's NIS paradigm). Most Vendors implement their WinSock.DLLs in a non-blocking manner, but to}{\f5 
 do the opposite is quite within the WinSock v1.1 specification; thus, you }{\b\i\f5 may}{\f5  have a perceptible delay when this property is accessed. 
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180\tx3510 {\f5 getservbyname(), getservbyport()
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180\tx3510 {\b\f5 String }{\f5 (HSZ)
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Scope
\par }\pard \li180\tx3510 {\f5 VB1.0+/VC++
\par }\pard {\b\f5 \page }{\b\f5\fs22 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETSERVER_SEEALSO_LOCALSERVICE}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb LocalPort}{\v\f5 NETSERVER_PROPERTY_LOCALPORT}{\f5 
\par }{\f5\uldb Listen}{\v\f5 NETSERVER_PROPERTY_LISTEN}{\f5 
\par }{\f5\uldb QueueSize}{\v\f5 NETSERVER_PROPERTY_QUEUESIZE}{\f5\uldb 
\par }\pard \tx3510 {\b\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETSERVER_PROPERTY_QUEUESIZE}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetServer QueueSize Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;QueueSize}}{\plain \b\f5\lang1033 QueueSize Property, NetServer Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETSERVER_SEEALSO_QUEUESIZE}{\b\f5 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 The }{\b\f5 QueueSize}{\f5  property is used to set the number o}{\f5 f allowed "queued" incoming connections. This is the exact value given to the listen() call.
\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetServer}{\f5 .}{\b\f5 QueueSize}{\f5 [}{\i\f5 = size%}{\f5 ]
\par }{\f5 [}{\i\f5 size%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetServer}{\f5 .}{\b\f5 QueueSize}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetServer->}{\b\f5 GetNumProperty("QueueSize")}{\f5 
\par }{\f5 pNetServer->}{\b\f5 SetNumProperty("QueueSize",}{\f5  }{\i\f5 size%}{\b\f5 )
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 You MUST set this property before you set the }{\f5\uldb Listen}{\v\f5 NETSERVER_PROPERTY_LISTEN}{\f5  property to }{\f5\cf2 True}{\f5 . If you set this property afterwards, it has no effect.
\par }{\f5 
\par }{\f5 The default Windows Sockets v1.1 value for this propert}{\f5 y is 5.
\par }{\f5 
\par }{\f5 This value currently has little effect other than to allow multiple clients to simulaneously connect to the listen() - after which one accept() at a time is handled. 
\par }{\f5 
\par }\pard \li180\brdrt\brdrs\brdrw30\brsp20 \brdrb\brdrs\brdrw30\brsp20 \tx3510 {\b\f5 Note:}{\f5  I can see no reason to change this value under the v1.1 spec, but I have included it }{\i\f5 just in case}{\f5 .
\par }\pard \li180\tx3510 {\f5 
\par }\pard {\b\f5 WinSock Calls
\par }\pard \li180 {\f5 This property is used when listen() is called when the }{\f5\uldb Listen}{\v\f5 NETSERVER_PROPERTY_LISTEN}{\f5  property is set to True.
\par }\pard {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 Integer}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard {\b\f5\fs22 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETSERVER_SEEALSO_QUEUESIZE}}{\b\f5\fs22 See also
\par }\pard \fi-1440\li1800\tx1080\tx2160\tx3240\tx4320 {\f5\uldb LocalPort}{\v\f5 NETSERVER_PROPERTY_LOCALPORT}{\f5 
\par }{\f5\uldb LocalService}{\v\f5 NETSERVER_PROPERTY_LOCALSERVICE}{\f5 
\par }{\f5\uldb Listen}{\v\f5 NETSERVER_PROPERTY_LISTEN}{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETSERVER_PROPERTY_SOCKET}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetServer Socket Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;Socket}}{\plain \b\f5\lang1033 Socket Property, NetServer Control
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\b\f5 Socket}{\f5  specifies the actual socket that is listening for incoming connections.
\par }{\f5 
\par }\pard {\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetServer}{\f5 .}{\b\f5 Socket}{\i\f5 =}{\f5 [}{\i\f5  socket%}{\f5 ]
\par }{\f5 [}{\i\f5 size%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetServer}{\f5 .}{\b\f5 Socket}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetServer->}{\b\f5 GetNumProperty("Socket")}{\f5 
\par }{\f5 pNetServer->}{\b\f5 SetNumProperty("Socket",}{\f5  }{\i\f5 socket%}{\b\f5 )
\par }\pard \tx3510 {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 If }{\f5\uldb Listen}{\v\f5 NETSERVER_PROPERTY_LISTEN}{\f5  is }{\f5\cf2 False}{\f5 , this property has no meaning when read. The socket() ca}{\f5 ll is not made until the }{\f5\uldb Listen}{\v\f5 NETSERVER_PROPERTY_LISTEN}{\f5 
 property is set.
\par }{\f5 
\par }{\f5 If }{\f5\uldb Listen}{\v\f5 NETSERVER_PROPERTY_LISTEN}{\f5  is }{\f5\cf2 False}{\f5 , and you set this property to either 0 or SOCKET_ERROR (-1), the }{\f5\uldb Listen}{\v\f5 NETSERVER_PROPERTY_LISTEN}{\f5  property will be set to }{\f5\cf2 False}{
\f5  - regardless. 
\par }{\f5 
\par }{\f5 There is no real reason to set the }{\b\f5 Socket}{\f5  property in the NetServer control, so it is currently NOT allowed (and will set the VB error VBERR_READONLY (383)).
\par }{\f5 
\par }{\f5 Do }{\i\f5 NOT}{\f5  attempt a closesocket() on this handle. It will not currently have any adverse}{\f5  affects (other than sporadic errors), but it might in future versions. Do }{\i\f5 NOT}{\f5  set this }{\b\f5 Socket}{\f5  to blocking, and do }
{\i\f5 NOT}{\f5  do a WSAAsyncSelect() on }{\b\f5 Socket}{\f5 , as it will surely break the current control. 
\par }{\f5 
\par }{\f5 For further reference, you may want to consult }{\f5\uldb What is a Socket?}{\v\f5 TOPIC_SOCKET}{\f5  and the WinSock.HLP file.
\par }\pard \tx3510 {\b\f5 
\par }\pard {\b\f5 WinSock Calls
\par }\pard \li180 {\f5 None.
\par }\pard {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 Integer
\par }\pard {\b\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETSERVER_PROPERTY_VERSION}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetServer Version Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;Version}}{\plain \b\f5\lang1033  Version Property, NetServer Control
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 This property reports the current revision of the NetServer control. The current ver}{\f5 sion of }{\i\f5 THIS}{\f5  WSANET.VBX distribution will return "v1.08alpha" as the version string.
\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 version$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetServer}{\f5 .}{\b\f5 Version}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetServer->}{\b\f5 GetStrProperty("Version")}{\f5 
\par }\pard {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 This property can }{\i\f5 NOT}{\f5  be set.
\par }{\f5 
\par }{\f5  You can use this property at run time to warn the user that the application may, }{\i\f5 or may not}{\f5 
, work with any newer version of the control. The NetServer control currently uses only 1 model - VB1.0 (although it does trick newer versions into thinking that it is VB2.0 in ord}{\f5 
er to allow context sensitive help). Because of this single model approach, there should be no future incompatibilities with versions of this control.
\par }{\f5 
\par }{\f5 This string is merely a way for programmers to deal with known incompatibilities of WSANET.VBX versions, and to report version information to the user. This is }{\i\f5 NOT}{\f5 
 the way for an application to realize the version of WinSock it is using - this version of WSANET does }{\i\f5 NOT}{\f5  support any version beside WinSock v1.1 (although future versions of certain Vendor's W}{\f5 
INSOCK.DLLs may support the earlier v1.1 API).
\par }\pard {\b\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180 {\f5 None.
\par }\pard {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 String }{\f5 (Hsz)
\par }\pard {\b\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard \tx3510 {\b\f5 \page }{\fs16\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETSERVER_SEEALSO_EVENTS}}{\b\f5  }{\b\f5\fs22 See Also
\par }\pard \ri7290\tx3510 {\f5\uldb OnAccept}{\v\f5 NETSERVER_EVENT_ONACCEPT}{\f5 
\par }{\f5\uldb OnError}{\v\f5 NETSERVER_EVENT_ONERROR}{\f5 
\par }{\f5 
\par }{\f5\uldb Using Events}{\v\f5 !JK("ctrlref.hlp", "Events, Using")}{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETSERVER_EVENT_ONACCEPT}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Ne
tServer OnAccept() Event}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Events;OnAccept()}}{\plain \b\f5\lang1033  OnAccept Event, NetServer Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETSERVER_SEEALSO_EVENTS}{\f5\fs18 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 Generated whenever a connection is accepted from a remote host.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \fi-2340\li2520\tx3510 {\b\f5 Sub }{\i\f5 NetServer}{\b\f5 _OnAccept(}{\f5 [}{\i\f5 Index}{\b\f5  As Integer}{\f5 ],  Socket }{\b\f5 As Integer}{\f5 , PeerAddr }{\b\f5 As String}{\f5 , Remo}{\f5 tePort }{\b\f5 As Integer)
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180\tx3510 {\f5 Function Signature:
\par }{\b\f5 void }{\i\f5 CMyDialog::On Outline OnAccept}{\b\f5 (UINT, int, CWnd*, LPVOID lpParams)
\par }\pard \tx3510 {\b\f5 
\par }\pard \li180\tx3510 {\f5 Parameter Usage:
\par }\pard \li180\brdrt\brdrs\brdrw30\brsp20 \brdrb\brdrs\brdrw30\brsp20 \tx3510 {\f5 I do not know how to access multiple VBX event parameters with the MFC2.0 classes.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 The }{\b\f5 OnAccept()}{\f5  event is generated whenever a connection from a remote host is accept()ed.
\par }{\f5 
\par }{\f5 After this event is fired, you shold hand the Socket event parameter to a NetClient control's Socket property in order to continue a connection. If, by checking the PeerAddr eve}{\f5 
nt parameter, you do not wish to talk to that host, you should set the Socket event parameter to -1 (SOCKET_ERROR) or 0 to close the accept()ed Socket.
\par }{\f5 
\par }{\f5 The following example code shows a simple OnAccept() event handler:
\par }{\f5 
\par }\pard \fi-2970\li3150\tx3510 {\f7\cf2 Sub}{\f7  NetServer_}{\f7\cf2 OnAccept}{\f7  (Socket }{\f7\cf2 As Integer}{\f7 , PeerAddr }{\f7\cf2 As String}{\f7 , RemotePort }{\f7\cf2 As Integer}{\f7 )
\par }\pard \li180\tx3510 {\f7\cf2     On Error Resume Next
\par }{\f7     If NetClient.Connect }{\f7\cf2 = True}{\f7  Then
\par }{\f7         Socket }{\f7\cf2 =}{\f7  0\tab }{\f7\cf11 ' Don't allow multiple fingers}{\f7 
\par }{\f7\cf2         Exit Sub
\par }{\f7\cf2     End If
\par }{\f7     NetClient.Socket }{\f7\cf2 =}{\f7  Socket
\par }{\f7\cf2 End Sub
\par }{\f5 
\par }\pard \tx3510 {\b\f5 WinSock Even}{\b\f5 ts
\par }\pard \li180\tx3510 {\f5 This event is fired on response to an FD_ACCEPT message.
\par }\pard \keepn\tx3510 {\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETSERVER_EVENT_ONERROR}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetServer OnError() Event}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Events;OnError()}}{\plain \b\f5\lang1033  OnError Event, NetServer Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETSERVER_SEEALSO_EVENTS}{\f5\fs18 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 Generated whenever an error of some kind occurs in the NetServer control.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180\tx3510 {\b\f5 Sub }{\i\f5 NetServer}{\b\f5 _OnError(}{\f5 [}{\i\f5 Index}{\b\f5  As Integer}{\f5 ], ErrorNumber}{\b\f5  As Integer)
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180\tx3510 {\f5 Function Signature:
\par }{\b\f5 void }{\i\f5 CMyDialog::On Outline OnError}{\b\f5 (UINT, int, CWnd*, LPVOID lpParams)
\par }\pard \tx3510 {\b\f5 
\par }\pard \li180\tx3510 {\f5 Parameter Usage:
\par }\pard \li180\brdrt\brdrs\brdrw30\brsp20 \brdrb\brdrs\brdrw30\brsp20 \tx3510 {\f5 I do not know how to access multiple VBX event parameters with the MFC2.0 }{\f5 classes.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 The }{\b\f5 ErrorNumber}{\f5  value and }{\f5\uldb ErrorMessage}{\v\f5 NETSERVER_PROPERTY_ERRORMESSAGE}{\f5  property can be used to identify the error that occurred.
\par }{\f5 
\par }\pard \tx3510 {\b\f5 WinSock Events
\par }\pard \li180\tx3510 {\f5 This event is fired whenever an error occurs. WSAGetLastError() is called by the NetServer control if the error was WinSock related before the }{\b\f5 OnError()}{\f5  event is fired. 
\par }\pard \keepn\tx1080\tx2160\tx3240\tx4320 {\plain \b\f5\up6\lang1033 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} TOPIC_CONTROL_NETCLIENT}}{\fs16\up6 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K}
 NetClient Control;Controls}}{\plain \b\f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetClient Control}}{\plain \b\f5\lang1033  \{bml netclnt.bmp\} WinSock Network Client Control 
\par }{\f5\fs18\ul Properties}{\v\f5\fs18 POPUP_NETCLIENT_PROPERTIES}{\f5\fs18 \tab }{\f5\fs18\ul Methods}{\v\f5\fs18 POPUP_NETCLIENT_METHODS}{\f5\fs18 \tab }{\f5\fs18\ul Events}{\v\f5\fs18 POPUP_NETCLIENT_EVENTS}{\f5\fs18 \tab }{\f5\fs18\uldb Errors}{
\v\f5\fs18 POPUP_NETCLIEN}{\v\f5\fs18 T_ERRORS}{\f5\fs18 \tab }{\f5\fs18\uldb Examples}{\v\f5\fs18 POPUP_NETCLIENT_EXAMPLES}{\f5\fs18 
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 You can use the NetClient control to access }{\f5\uldb Windows Sockets}{\v\f5 TOPIC_SOCKET}{\f5  v1.1 services. This control is invisible at run time, much like the timer control provided with Visual Basic.
\par }\pard {\f5 
\par }{\b\f5 File name
\par }\pard \li180 {\f5 WSANET.VBX
\par }\pard {\f5 
\par }{\b\f5 Object Type
\par }\pard \li180 {\f5 NetClient
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 The NetClient control uses functionality provided by a vendor specific version of WINSOCK.DLL that is provided with your TCP/IP protocol kernel. With this control, you can access any TCP service that is running }{\f5 
on a TCP/IP host. This control supports the TCP client side paradigm only, you must use the }{\f5\uldb NetServer}{\v\f5 TOPIC_CONTROL_NETSERVER}{\f5 
 control in order to write server/daemon applications. UDP and OOB communication are not yet supported in this version.
\par }{\f5 
\par }{\f5 See }{\f5\uldb About this project}{\v\f5 TOPIC_ABOUT}{\f5  for more general information
\par }{\f5 See the }{\f5\uldb Changes}{\v\f5 TOPIC_CHANGES}{\f5  that have been made to this version.
\par }{\f5 See the public domain }{\f5\uldb Copyright}{\v\f5 TOPIC_COPYRIGHT}{\f5  information for distribution availability.
\par }{\f5 
\par }\pard \li180\brdrt\brdrs\brdrw15\brsp20 \brdrb\brdrs\brdrw15\brsp20 {\b\f5 Distribution Note}{\f5 \tab When you create and dis}{\f5 
tribute applications written with the NetClient control, you should copy the file RELEASE.VBX as WSANET.VBX into your user's \\SYSTEM subdirectory or otherwise in the system path. The WSANET.VBX file distributed with the project is a debugging version.

\par }\pard {\f5 \page }{\fs16\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_PROPERTIES}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetClient Properties, Alphabetical Index of}}{\fs16\up6 K
{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K }Properties}}{\f5  }{\b\f5 Properties
\par }\pard \li180 {\f5 These are the properties for the NetClient Control. Properties that apply }{\i\f5 only}{\f5  to this client control, or that require special consideration when using it, are marked with an asterisk (*).
\par }{\f5 
\par }\trowd \trgaph108\trleft252 \cellx2232\cellx3927\cellx5637\cellx7362\pard \intbl {\f5\uldb *About}{\v\f5 PROPERTY_ABOUT}{\f5 \cell }{\f5\uldb *HostAliasCount}{\v\f5 NETCLIENT_PRO}{\v\f5 PERTY_HOSTALIASCOUNT}{\f5 \cell }{\f5 Parent\cell }{\f5\uldb 
*SendLine}{\v\f5 NETCLIENT_PROPERTY_SENDLINE}{\f5 \cell }\pard \intbl {\f5 \row }\trowd \trgaph108\trleft252 \cellx2232\cellx3927\cellx5637\cellx7362\pard \intbl {\f5\uldb *Block}{\v\f5 NETCLIENT_PROPERTY_BLOCK}{\f5 \cell }{\f5\uldb *HostAliasList}{\v\f5 
NETCLIENT_PROPERTY_HOSTALIASLIST}{\f5 \cell }{\f5\uldb *RecvBlock}{\v\f5 NETCLIENT_PROPERTY_RECVBLOCK}{\f5 \cell }{\f5\uldb *SendSize}{\v\f5 NETCLIENT_PROPERTY_SENDSIZE}{\f5 \cell }\pard \intbl {\f5 \row }\pard \intbl {\f5\uldb *Connect}{\v\f5 
NETCLIENT_PROPERTY_CONNECT}{\f5 \cell }{\f5\uldb *HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5 \cell }{\f5\uldb *RecvCount}{\v\f5 NETCLIENT_PROPERTY_RECVCOUNT}{\f5 \cell }{\f5\uldb *SendThreshold}{\v\f5 NETCLIENT_PROPERTY_SENDTHRESHOLD}{\f5 \cell 
}\pard \intbl {\f5 \row }\pard \intbl {\f5\uldb *Debug}{\v\f5 NETCLIENT_PROPERTY_DEBUG}{\f5 \cell }{\f5 Index\cell }{\f5\uldb *RecvLine}{\v\f5 NETCLIENT_PROPERTY_RECVLINE}{\f5 \cell }{\f5\uldb *Socket}{\v\f5 NETCLIENT_PROPERTY_SOCKET}{\f5 \cell }\pard 
\intbl {\f5 \row }\pard \intbl {\f5\uldb *Erro}{\f5\uldb rMessage}{\v\f5 NETCLIENT_PROPERTY_ERRORMESSAGE}{\f5 \cell }{\f5 Left\cell }{\f5\uldb *RecvSize}{\v\f5 NETCLIENT_PROPERTY_RECVSIZE}{\f5 \cell }{\f5\uldb *TimeOut}{\v\f5 NETCLIENT_PROPERTY_TIMEOUT}{
\f5 \cell }\pard \intbl {\f5 \row }\pard \intbl {\f5\uldb *ErrorNumber}{\v\f5 NETCLIENT_PROPERTY_ERRORNUMBER}{\f5 \cell }{\f5\uldb *Line}{\v\f5 NETCLIENT_PROPERTY_LINE}{\f5 \cell }{\f5\uldb *RecvThreshold}{\v\f5 NETCLIENT_PROPERTY_RECVTHRESHOLD}{\f5 
\cell }{\f5 Tag\cell }\pard \intbl {\f5 \row }\pard \intbl {\f5\uldb *Host}{\v\f5 NETCLIENT_PROPERTY_HOST}{\f5 \cell }{\f5\uldb *LineDelimiter}{\v\f5 NETCLIENT_PROPERTY_LINEDELIMITER}{\f5 \cell }{\f5\uldb *RemotePort}{\v\f5 NETCLIENT_PROPERTY_REMOTEPORT}{
\f5 \cell }{\f5 Top\cell }\pard \intbl {\f5 \row }\pard \intbl {\f5\uldb *HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5 \cell }{\f5\uldb *LocalPort}{\v\f5 NETCLIENT_PROPERTY_LOCALPORT}{\f5 \cell }{\f5\uldb *RemoteService}{\v\f5 
NETCLIENT_PROPERTY_REMOTESERVICE}{\f5 \cell }{\f5\uldb *Versio}{\f5\uldb n}{\v\f5 NETCLIENT_PROPERTY_VERSION}{\f5 \cell }\pard \intbl {\f5 \row }\pard \intbl {\f5\uldb *HostAddressCount}{\v\f5 NETCLIENT_PROPERTY_HOSTADDRESSCOUNT}{\f5 \cell }{\f5\uldb 
*LocalService}{\v\f5 NETCLIENT_PROPERTY_LOCALSERVICE}{\f5 \cell }{\f5\uldb *SendBlock}{\v\f5 NETCLIENT_PROPERTY_SENDBLOCK}{\f5 \cell }{\f5 \cell }\pard \intbl {\f5 \row }\trowd \trgaph108\trleft252 \cellx2232\cellx3927\cellx5637\cellx7362\pard \intbl {
\f5\uldb *HostAddressList}{\v\f5 NETCLIENT_PROPERTY_HOSTADDRESSLIST}{\f5 \cell }{\f5 Name\cell }{\f5\uldb *SendCount}{\v\f5 NETCLIENT_PROPERTY_SENDCOUNT}{\f5 \cell }{\f5 \cell }\pard \intbl {\f5 \row }\pard {\f5 
\par }\pard \li180 {\f5\uldb Line}{\v\f5 NETCLIENT_PROPERTY_LINE}{\f5  is the default property.
\par }\pard {\f5 \page }{\b\f5\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_METHODS}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Methods}}{\b\f5  Methods
\par }\pard \li180 {\f5 This current version of the NetClient control supports no custom Methods.\page }{\b\fs16\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_EVENTS}}{\b\f5  }{\fs16\up6 ${\footnote \pard\plain \s245 
\f3\fs20\lang1033 {\fs16\up6 $} Events}}{\b\f5  Events
\par }\pard {\f5 
\par }\pard \li180 {\f5 The NetClient control uses 6 custom Events in order to support Asyncronous Win}{\f5 dows Sockets.
\par }{\f5 
\par }\trowd \trgaph108\trleft207 \cellx1605\cellx2778\cellx4011\cellx5289\cellx6477\cellx7920\pard \li180\intbl {\f5\uldb OnConnect}{\v\f5 NETCLIENT_EVENT_ONCONNECT}{\f5 \cell }{\f5\uldb OnRecv}{\v\f5 NETCLIENT_EVENT_ONRECV}{\f5 \cell }{\f5\uldb OnSend}{
\v\f5 NETCLIENT_EVENT_ONSEND}{\f5 \cell }{\f5\uldb OnClose}{\v\f5 NETCLIENT_EVENT_ONCLOSE}{\f5 \cell }{\f5\uldb OnError}{\v\f5 NETCLIENT_EVENT_ONERROR}{\f5 \cell }{\f5\uldb OnTimeOut}{\v\f5 NETCLIENT_EVENT_ONTIMEOUT}{\f5 \cell }\pard \intbl {\f5 \row 
}\pard {\b\fs16\up6 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_ERRORS}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Errors}}{\b\f5  Errors
\par }\pard \qj\li180 {\f5\uldb Windows Sockets errors}{\v\f5 TOPIC_WINSOCKERRORS}{\f5  are returned by triggering the }{\f5\uldb OnError()}{\v\f5 NETCLIENT_EVENT_ONERROR}{\f5  event, and setting the }{\f5\uldb ErrorNumber}{\v\f5 NETCLIENT_PROPERTY_ERRORNUMBER
}{\f5  and }{\f5\uldb ErrorMessage}{\v\f5 NETCLIENT_PROPERTY_ERRORMESSAGE}{\f5  properties appropriately.
\par }\pard {\f5 
\par }\pard \qj\li180 {\f5 The NetClient control currently sets }{\f5 the following errors:
\par }{\f5 
\par }\trowd \trgaph108\trleft192 \cellx3807\cellx4902\pard \qj\li180\intbl {\f5 ERR_OUTOFMEMORY\cell }{\f5 7\cell }\pard \intbl {\f5 \row }\trowd \trgaph108\trleft192 \cellx3807\cellx4902\pard \qj\li180\intbl {\f5 VBERR_INVALIDPROPERTYVALUE \cell }{\f5 380
\cell }\pard \intbl {\f5 \row }\pard \qj\li180\intbl {\f5 VBERR_BADVBINDEX\cell }{\f5 381\cell }\pard \intbl {\f5 \row }\pard \qj\li180\intbl {\f5 VBERR_READONLY\cell }{\f5 383  \cell }\pard \intbl {\f5 \row }\pard \qj\li180\intbl {\f5 VBERR_WRITEONLY
\cell }{\f5 394\cell }\pard \intbl {\f5 \row }\pard \qj\li180\intbl {\f5 WSAERR_BadHostAddr\cell }{\f5 20000\cell }\pard \intbl {\f5 \row }\pard \qj\li180\intbl {\f5 WSAERR_AlreadyConn\cell }{\f5 20001\cell }\pard \intbl {\f5 \row }\pard \qj\li180\intbl {
\f5 WSAERR_NoTimers\cell }{\f5 20002\cell }\pard \intbl {\f5 \row }\pard \qj\li180\intbl {\f5 WSAERR_RecvBuffer\cell }{\f5 20003\cell }\pard \intbl {\f5 \row }\pard \qj\li180\intbl {\f5 WSAERR_SendOverFlow\cell }{\f5 20004\cell }\pard \intbl {\f5 \row 
}\trowd \trgaph108\trleft192 \cellx3807\cellx4902\pard \qj\li180\intbl {\f5 WSAERR_NotConn\cell }{\f5 20005\cell }\pard \intbl {\f5 \row }\pard {\f5 
\par }{\f5 These errors are all contained within the "constants" file WSANET.TXT
\par }{\f5 
\par }{\f5 You MUST use }{\f5\cf2 On Error}{\f5  handlers to trap these errors.
\par }\pard \qc\keepn {\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_EXAMPLES}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} Coding Examples}}{
\fs16\up6 k{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 k} Examples}}{\plain \b\f5\lang1033  Coding Examples
\par }\pard \li180 {\f5 
\par }{\f5 WSANET.VBX is origionally packaged }{\f5 
with 5 example programs that show how to use the NetClient control effectively. All examples have been tested in VB2.0 and VB3.0, and are shown here in text saved format. Only the VB2.0 examples are included in this HLP file for space considerations.

\par }{\f5 
\par }\pard \fi-2160\li2340\tx1440 {\f5 WFinger\tab \tab A simple finger client. Shows how to carry on a simple conversation.
\par }{\f5 WiNslookup\tab -\tab A NSLookup like application. Shows how to use }{\f5\ul DNS}{\v\f5 POPUP_DNS}{\f5  and I.P lookup properties.
\par }{\f5 WSMTPC\tab -\tab A simple SMTP client. Shows how to make a state-based client applicati}{\f5 on.
\par }{\f5 WinWhois\tab -\tab A "NicName" or WHOIS client. Shows how to use the INI control, and the NetClient control in a real application.
\par }{\f5 WFingerD\tab -\tab A simple finger server. Shows how to use the }{\f5\uldb NetServer}{\v\f5 TOPIC_CONTROL_NETSERVER}{\f5  control with 1 connection at a time service.
\par }{\f5 VB-SMTPD\tab -\tab A complex SMTP daemon. Shows how to create an unlimited connection state server with the }{\f5\uldb NetServer}{\v\f5 TOPIC_CONTROL_NETSERVER}{\f5  control.
\par }\pard \li180 {\f5 
\par }{\f5 In order to use the above examples, you may locate the relevant materials and use WinHelp's Edit/Copy m}{\f5 enu to copy the selected source directly into your code window.
\par }\pard \keepn {\plain \b\f5\up6\lang1033 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} PROPERTY_ABOUT}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} About Property}}{\fs16\up6 K{\footnote \pard\plain \s245 
\f3\fs20\lang1033 {\fs16\up6 K} Properties;About}}{\plain \b\f5\lang1033  About Property, NetClient & NetServer Controls
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 Shows the Author and version of your current WSANET.VBX during design time.
\par }\pard {\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 Design time only
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 Design time only.
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 This property merely shows the current version "stepping" of WSANET.VBX and the author's name in a dialog box form. This should be of little importance to the application developer. For more project information, read }{\f5\uldb 
About thi}{\f5\uldb s project}{\v\f5 TOPIC_ABOUT}{\f5  and }{\f5\uldb Thanks}{\v\f5 TOPIC_THANKS}{\f5 
\par }\pard {\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180 {\f5 None.
\par }\pard {\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\f5 None.}{\b\f5  }{\f5 (Only a VBM_GETPROPHSZ response)
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard \keepn {\f5 \page }{\fs16\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_BLOCK}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetClient Block Property}}{\fs16\up6 K{\footnote 
\pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;Block}}{\plain \b\f5\lang1033  Block Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_BLOCK}{\f5\fs18 
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 Sends or receives a block of raw binary data from/to a connected Socket.
\par }\pard {\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5 NetClient}{\f5  .}{\b\f5 Block}{\f5 [}{\i\f5 = setting$}{\f5 ]
\par }{\f5 [}{\i\f5 setting$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 Block}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 Visual C++ cannot Access Visual Basic strings. (HLSTR is implemented as a property only in VB2.}{\f5 00+) Consult the }{\f5\uldb NetClientSendBlock()}{\v\f5 EXPORT_NETCLIENTSENDBLOCK}{\f5  and }{\f5\uldb NetClientRecvBlock()}{\v\f5 
EXPORT_NETCLIENTRECVBLOCK}{\f5  DLL function exports for more information.
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 This property is nothing more than BOTH the }{\f5\uldb SendBlock}{\v\f5 NETCLIENT_PROPERTY_SENDBLOCK}{\f5  and }{\f5\uldb RecvBlock}{\v\f5 NETCLIENT_PROPERTY_RECVBLOCK}{\f5 
 properties combined into a single property. Setting this property invokes }{\f5\uldb SendBlock}{\v\f5 NETCLIENT_PROPERTY_SENDBLOCK}{\f5 , and getting this property invokes }{\f5\uldb RecvBlock}{\v\f5 NETCLIENT_PROPERTY_RECVBLOCK}{\f5 .
\par }\pard {\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180 {\f5 See the }{\f5\uldb RecvBloc}{\f5\uldb k}{\v\f5 NETCLIENT_PROPERTY_RECVBLOCK}{\f5  and }{\f5\uldb SendBlock}{\v\f5 NETCLIENT_PROPERTY_SENDBLOCK}{\f5  properties.
\par }\pard {\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 String}{\f5  (HLSTR)
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB2.0+
\par }\pard {\f5 
\par }{\f5 \page }{\b\f5\fs22 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_BLOCK}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb RecvBlock}{\v\f5 NETCLIENT_PROPERTY_RECVBLOCK}{\f5 
\par }{\f5\uldb SendBlock}{\v\f5 NETCLIENT_PROPERTY_SENDBLOCK}{\f5 
\par }\pard \keepn {\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_CONNECT}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetClient Connect Property}}{\fs16\up6 
K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;Connect}}{\plain \b\f5\up6\lang1033  }{\plain \b\f5\lang1033 Connect Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_CONNECT}{\f5\fs18 
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 Reports or sets the current connection status of the associated socket.
\par }\pard {\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 Connect}{\f5 [}{\i\f5 = state%}{\f5 ]
\par }{\f5 [}{\i\f5 state%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 Connect}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 G}{\b\f5 etNumProperty("Connect")}{\f5 
\par }{\f5 pNetClient->}{\b\f5 SetNumProperty("Connect",}{\f5  }{\i\f5 state}{\b\f5 )
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 Setting this property to }{\f5\cf2 True}{\f5  (<>0, or -1 in VB) will cause the control to try and connect to a remote host. Set  this property to True only when you have set the }{\f5\uldb RemotePort}{\v\f5 
NETCLIENT_PROPERTY_REMOTEPORT}{\f5  and }{\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5 /}{\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5  pair to the desired TCP port and machine name for the remote host. 
\par }{\f5 
\par }{\f5 If you set }{\f5\uldb LocalPort}{\v\f5 NETCLIENT_PROPERTY_LOCALPORT}{\f5  to non-zero, a bind() will exe}{\f5 cuted to bind the local end of the port to the desired port. If }{\f5\uldb LocalPort}{\v\f5 NETCLIENT_PROPERTY_LOCALPORT}{\f5 
 is zero, no binding is performed, and the WinSock connect() call will bind() the local end to a benign port.
\par }{\f5 
\par }{\f5 Setting this property to }{\f5\cf2 False}{\f5  (=0) will cause the control to terminate any ongoing connections with the remote host via the closesocket() call.
\par }\pard {\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180 {\f5 socket(), WSAAsyncSelect(), bind(), connect(), closesocket()
\par }\pard {\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 Integer
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard {\f5 \page }{\b\f5\fs22 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_CONNECT}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb HostName}{\v\f5 NETCLIENT}{\v\f5 _PROPERTY_HOSTNAME}{\f5 
\par }{\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5 
\par }{\f5\uldb LocalPort}{\v\f5 NETCLIENT_PROPERTY_LOCALPORT}{\f5 
\par }{\f5\uldb RemotePort}{\v\f5 NETCLIENT_PROPERTY_REMOTEPORT}{\f5 
\par }\pard \keepn {\f5 \page }{\plain \b\f5\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_DEBUG}}{\plain \b\f5\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $ }NetClient Debug Property}}
{\plain \b\f5\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;Debug}}{\plain \b\f5\lang1033  Debug Property, NetClient Control
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 Sets or returns the current state of the SO_DEBUG socket option.
\par }\pard {\f5  
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 Debug }{\f5 [}{\i\f5 = bool%}{\f5 ]
\par }{\f5 [}{\i\f5 bool%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 Debug}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetNumProperty("Debug")}{\f5 
\par }{\f5 pNetClient->}{\b\f5 SetNumProperty("Debug",}{\i\f5 bool%}{\b\f5 )
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 This property reflects the current socket level debugging stat}{\f5 e of a connected socket.
\par }{\f5 
\par }{\f5 When setting this property, if }{\f5\uldb Connect}{\v\f5 NETCLIENT_PROPERTY_CONNECT}{\f5  is }{\f5\cf2 False}{\f5 , WSAERR_NotConn (error 20000) is set by the control, and no action is taken. If }{\f5\uldb Connect}{\v\f5 NETCLIENT_PROPERTY_CONNECT}{
\f5  is True, setsockopt() is called, or the }{\f5\uldb ErrorNumber}{\v\f5 NETCLIENT_PROPERTY_ERRORNUMBER}{\f5  property is set to the appropriate }{\f5\uldb WinSock error}{\v\f5 TOPIC_WINSOCKERRORS}{\f5 .
\par }{\f5 
\par }{\f5 When reading this property, if }{\f5\uldb Connect}{\v\f5 NETCLIENT_PROPERTY_CONNECT}{\f5  is }{\f5\cf2 False}{\f5 , }{\f5\cf2 False}{\f5  is ALWAYS returned. If }{\f5\uldb Connect}{\v\f5 NETCLIENT_PROPERTY_CONNECT}{\f5  is }{\f5\cf2 T}{\f5\cf2 rue}{
\f5 , getsockopt() is called, or the }{\f5\uldb ErrorNumber}{\v\f5 NETCLIENT_PROPERTY_ERRORNUMBER}{\f5  property is set to the appropriate }{\f5\uldb WinSock error}{\v\f5 TOPIC_WINSOCKERRORS}{\f5 .
\par }{\f5 
\par }{\f5 
The debugging information supplied by most WinSock vendors is in the form of OutputDebugString() calls. In order to view this debugging information, you will need the DBWIN application from the 3.1 SDK, or an equivalent application that hooks the debuggin
}{\f5 g output.
\par }\pard {\f5 
\par }{\b\f5 WinSock calls
\par }\pard \li180 {\f5 getsockopt(), setsockopt()
\par }\pard {\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 Integer}{\f5  (Boolean)
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC+}{\f5 +
\par }\pard \keepn {\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_ERRORMESSAGE}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetClient ErrorMessage Property}}{
\fs16\up6 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;ErrorMessage}}{\plain \b\f5\lang1033  ErrorMessage Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_ERRORMESSAGE}{\f5\fs18 
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 Returns the error message for the }{\f5\uldb ErrorNumber}{\v\f5 NETCLIENT_PROPERTY_ERRORNUMBER}{\f5  property.
\par }\pard {\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 message$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 ErrorMessage}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetStrProperty("ErrorMessage")}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 This property corresponds to the }{\f5\uldb ErrorNumber}{\v\f5 NETCLIENT_PROPERTY_ERRORNUMBER}{\f5  property. The VBX's resource string table is used to get the corresponding error message.
\par }\pard {\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180 {\f5 No}{\f5 ne.
\par }\pard {\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 String }{\f5 (HSZ)
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard {\b\f5\fs22 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_ERRORMESSAGE}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb ErrorNumber}{\v\f5 NETCLIENT_PROPERTY_ERRORNUMBER}{\f5 
\par }{\f5 OnError()
\par }\pard \keepn {\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_ERRORNUMBER}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetClient ErrorNumber Property}}{
\fs16\up6 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;Errors;ErrorNumber}}{\plain \b\f5\lang1033  ErrorNumber Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_ERRORNUMBER}{\f5\fs18 
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 Reports any error condition from the NetClient control.
\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 ErrorNumber }{\f5 [}{\i\f5 = status%}{\f5 ]
\par }{\f5 [}{\i\f5 status%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 ErrorNumber}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetNumProperty("ErrorNumber")}{\f5 
\par }{\f5 pNetClient->}{\b\f5 SetNumProperty("ErrorNumber",}{\i\f5 status%}{\b\f5 )
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 This pro}{\f5 perty returns any error at the Windows Sockets level, or other miscellaneous errors caused by control usage error. You can set this property at any time in your application. The }{\f5\uldb ErrorMessage}{\v\f5 
NETCLIENT_PROPERTY_ERRORMESSAGE}{\f5  property returns strings based upon the value stored in this property.
\par }{\f5 
\par }{\f5 Please consult }{\f5\uldb WinSock Errors}{\v\f5 TOPIC_WINSOCKERRORS}{\f5  for more information on WinSock specific errors.
\par }\pard \tx3960 {\f5 
\par }\pard {\b\f5 WinSock Calls
\par }\pard \li180 {\f5 WSAGetLastError() is called to get the error status whenever a WinSock function returns SOCKET_ERROR}{\f5 . Therefore, this property does not call any WinSock related functions; }{\b\f5 ErrorNumbe}{\f5 r is set as the error occurs.

\par }\pard {\f5 
\par }{\b\f5 Data Type
\par }\pard \li180\tx3510 {\b\f5 Integer
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard {\b\f5\fs22 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_ERRORNUMBER}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb ErrorMessage}{\v\f5 NETCLIENT_PROPERTY_ERRORMESSAGE}{\f5 
\par }{\f5\uldb OnError()}{\v\f5 NETCLIENT_EVENT_ONERROR}{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_HOST}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetClient Host Property}}{
\fs16\up6 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;Host}}{\plain \b\f5\lang1033  Host Property, NetClient Control
\par }\pard \keepn {\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_HOST}{\f5\fs18 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 This property is used to resolve an I.P. number or DNS name, and set the remote host's address for socket communication.
\par }{\f5 
\par }\pard {\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 Host}{\f5 [}{\i\f5 = host$}{\f5 ]
\par }{\f5 [}{\i\f5 h}{\i\f5 ost$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 Host
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetStrProperty("Host")}{\f5 
\par }{\f5 pNetClient->}{\b\f5 SetStrProperty("Host",}{\f5  hostaddr}{\b\f5 )
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 When set, first a }{\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5  lookup, and then a }{\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5  lookup is attempted on the host name.
\par }{\f5 
\par }{\f5 This property returns the same thing as }{\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5  (it uses the same property handling code).
\par }{\f5 
\par }{\f5 Please see the }{\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5  and }{\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5  propertie}{\f5 s for the full description.
\par }{\f5 
\par }{\f5 This property is merely a "convenience" property for applications to avoid checking both of the above properties during a user input.
\par }{\f5 
\par }\pard \li180\brdrt\brdrdb\brdrw15\brsp20 \brdrb\brdrdb\brdrw15\brsp20 {\f5 Currently, setting this property invokes the corresponding }{\i\f5 blocking}{\f5 
 call of your WinSock. This is not the best way to implement this functionality. A better way would be to add a OnGetHost() event and a HostAsync property. If this were used, WSAAsyncGetHostByAddr() could be used, and your application would not block. Whi
}{\f5 le your application }{\i\f5 bl}{\i\f5 ocks}{\f5 , your application will }{\i\f5 stick}{\f5  until it completes.
\par }\pard {\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180 {\f5 inet_ntoa(), inet_addr(), gethostbyaddr(), gethostbyname()
\par }\pard {\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 String }{\f5 (HSZ)
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard {\b\f5\fs22 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_HOST}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5 
\par }{\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5 
\par }\pard \li180\tx3510 {\f5\uldb HostAddressCount}{\v\f5 NETCLIENT_PROPERTY_HOSTADDRESSCOUNT}{\f5 
\par }{\f5\uldb HostAddressList}{\v\f5 NETCLIENT_PROPERTY_HOSTADDRESSLIST}{\f5 
\par }{\f5\uldb HostAliasCount}{\v\f5 NETCLIENT_PROPERTY_HOSTALIASCOUNT}{\f5 
\par }{\f5\uldb HostAlistList}{\v\f5 NETCLIENT_PROPERTY_HOSTALIASLIST}{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_HOSTADDR}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetClient HostAddr Property}}
{\fs16\up6 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;HostAddr}}{\plain \b\f5\lang1033  HostAddr Property, NetClient Control
\par }\pard \keepn {\f5\fs18\ul Se}{\f5\fs18\ul e Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_HOSTADDR}{\f5\fs18 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 This property is used to resolve an I.P. number and set the remote host's address for socket communication.
\par }{\f5 
\par }\pard {\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 HostAddr}{\f5 [}{\i\f5 = hostaddr$}{\f5 ]
\par }{\f5 [}{\i\f5 hostaddr$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 HostAddr
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetStrProperty("HostAddr")}{\f5 
\par }{\f5 pNetClient->}{\b\f5 SetStrProperty("HostAddr",}{\f5  hostaddr}{\b\f5 )
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 At run time, this property initially holds the I.P. address of your local host (or "" if your WinSock is substandard).
\par }{\f5 
\par }{\f5 Setting this}{\f5  property to a host number string invokes the name resolver. Your program will temporarily block (for often no more than a fraction of a second) while a }{\f5\ul DNS}{\v\f5 POPUP_DNS}{\f5 
 lookup is made through your local name server or local }{\i\f5 hosts}{\f5  file on your PC. If an error occurs, this property will be set to a empty string ("") , the }{\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5 
 property will be set to an empty string ("") and the }{\f5\uldb OnError()}{\v\f5 NETCLIENT_EVENT_ONERROR}{\f5  event will be called with the appropriate WinSock error. If no error oc}{\f5 
curs, this property will be set to the I.P. address of the host, and the }{\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5  property will be set to the correct }{\f5\ul FQDN}{\v\f5 POPUP_FQDN}{\f5  of the host.
\par }{\f5 
\par }{\f5 Reading this property will be the result of any previous }{\i\f5 set}{\f5  operation, or your local PC's I.P. address}{\v\f5 POPUP_FQDN}{\f5  if it is the first time you access it.
\par }{\f5 
\par }{\f5 If you use this property on a Connected session, you will loose all reference to the machine that the control }{\i\f5 was}{\f5  talking to. The socket communications will proceed, but it becomes}{\f5 
 your application's responsibility to know who it is talking to.
\par }{\f5 
\par }{\f5 You only need to set }{\b\f5 HostAddr}{\f5  OR }{\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5 ; setting both is unnecessarily redundant. After setting one of these properties, the other is set appropriately.
\par }{\f5 
\par }{\f5 If the requested Host is in your WinSock.DLL's database (most likely from a file named "hosts" in its path), no blocking }{\i\f5 should}{\f5 
 be involved - but this seems to be vendor specific. If your vendor's WinSock.DLL does not block as it reads its database, there sho}{\f5 uld be no actual delay as normal DNS lookups would incur.
\par }{\f5 
\par }{\f5 
\par }\pard \li180\brdrt\brdrdb\brdrw15\brsp20 \brdrb\brdrdb\brdrw15\brsp20 {\f5 Currently, setting this property invokes the corresponding }{\i\f5 blocking}{\f5 
 call of your WinSock. This is not the best way to implement this functionality. A better way would be to add a OnGetHost() event and a HostAsync property. If this were used, WSAAsyncGetHostByAddr() could be used, and your application would not block. Whi
}{\f5 le your application }{\i\f5 blocks}{\f5 , your application will }{\i\f5 stick}{\f5  until it completes.
\par }\pard {\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180 {\f5 inet_ntoa(), inet_addr(), gethost}{\f5 byaddr()
\par }\pard {\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 String }{\f5 (HSZ)
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard {\b\f5\fs22 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_HOSTADDR}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5 
\par }\pard \li180\tx3510 {\f5\uldb HostAddressCount}{\v\f5 NETCLIENT_PROPERTY_HOSTADDRESSCOUNT}{\f5 
\par }{\f5\uldb HostAddressList}{\v\f5 NETCLIENT_PROPERTY_HOSTADDRESSLIST}{\f5 
\par }{\f5\uldb HostAliasCount}{\v\f5 NETCLIENT_PROPERTY_HOSTALIASCOUNT}{\f5 
\par }{\f5\uldb HostAlistList}{\v\f5 NETCLIENT_PROPERTY_HOSTALIASLIST}{\f5 
\par }{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_HOSTADDRESSCOUNT}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient HostAddressCount Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;HostAddressCount}}{\plain \f5\up6\lang1033  }{\plain \b\f5\lang1033 HostAddressCount Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_HOSTADDRESSCOUNT}{\f5\fs18 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 This property holds the current number of elements in the }{\f5\uldb HostAddressList}{\v\f5 NETCLIENT_PROPE}{\v\f5 RTY_HOSTADDRESSLIST}{\f5  property array. This number signifies the number of I.P. Addresses for a DNS host.

\par }\pard \tx3510 {\b\f5 
\par }\pard {\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 count%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 HostAddressCount}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetNumProperty("HostAddressCount")}{\f5 
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 When you set }{\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5  or }{\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5 , this property is set automagically.
\par }\pard \li180\tx3510 {\f5 
\par }{\f5 Setting }{\b\f5 HostAddressCount}{\f5  will return VBERR_WRITEONLY (383).
\par }{\f5 
\par }{\f5 Reading }{\b\f5 HostAddressCount}{\f5  will tell you the number of I.P. strings contained in t}{\f5 he }{\f5\uldb HostAddressList()}{\v\f5 NETCLIENT_PROPERTY_HOSTADDRESSLIST}{\f5 
 property array. Do NOT attempt to read past this limit, or you will receive VBERR_BADVBINDEX (381).
\par }\pard \tx3510 {\b\f5 
\par }\pard {\b\f5 WinSock Calls
\par }\pard \li180 {\f5 None. This property calls no actual WinSock calls. The number returned is from the number of h_address_list[] entries in the HOSTENT structure returned by gethostbyname()/gethostbyaddr().
\par }{\f5 
\par }\pard {\b\f5 Data Type
\par }\pard \li180 {\b\f5 Integer
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180\tx3510 {\f5 VB1.0+/VC++
\par }\pard \tx3510 {\b\f5 \page }{\b\f5\fs22\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_HOSTADDRESSCOUNT}}{\b\f5\fs22 See also
\par }\pard \li187\tx3510 {\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5 
\par }{\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5 
\par }{\f5\uldb HostAddressList}{\v\f5 NETCL}{\v\f5 IENT_PROPERTY_HOSTADDRESSLIST}{\f5 
\par }{\f5\uldb HostAliasCount}{\v\f5 NETCLIENT_PROPERTY_HOSTALIASCOUNT}{\f5 
\par }{\f5\uldb HostAliasList}{\v\f5 NETCLIENT_PROPERTY_HOSTALIASLIST}{\f5 
\par }{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \b\f5\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_HOSTADDRESSLIST}}{\plain \b\f5\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient HostAddressList Property}}{\plain \b\f5\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;HostAddressList}}{\plain \b\f5\lang1033  HostAddressList Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_HOSTADDRESSLIST}{\f5\fs18 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 This property array holds the I.P. strings returned via gethostbyname()/gethostbyaddr().
\par }{\f5 
\par }\pard {\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 hostaddr$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 HostAddressList(}{\i\f5 index}{\b\f5 )}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180\brdrt\brdrs\brdrw30\brsp20 \brdrb\brdrs\brdrw30\brsp20 \tx3510 {\f5 I do not know how VC++ uses property arrays.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 When you set }{\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPER}{\v\f5 TY_HOSTADDR}{\f5  or }{\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5 , this property is set automagically.
\par }\pard \li180\tx3510 {\f5 
\par }{\f5 This property array holds the h_address_list[] array as returned through the HOSTENT structure by gethostbyname()/gethostbyaddr(). 
\par }{\f5 
\par }{\f5 The number of elements of this array is available through the }{\f5\uldb HostAddressCount}{\v\f5 NETCLIENT_PROPERTY_HOSTADDRESSCOUNT}{\f5  property. Do NOT attempt to access the }{\b\f5 HostAddressList()}{\f5 
 array past this limit, or you will receive VBERR_BADVBINDEX (381).
\par }{\f5 
\par }{\f5 By using the }{\i\f5 index}{\f5  to step through the array,}{\f5  you can find all I.P. addresses for a remote host. This helps multi-homed clients and applications that need to know multiple "routes" to a remote host.
\par }{\f5 
\par }{\b\f5 HostAddressList(0)}{\f5  will ALWAYS hold the same value as }{\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5 , so }{\f5\uldb HostAddressCount}{\v\f5 NETCLIENT_PROPERTY_HOSTADDRESSCOUNT}{\f5  will always be 1 if }{\f5\uldb HostAddr}{
\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5  holds a valid I.P string.
\par }\pard {\b\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180 {\f5 None. This property calls no actual WinSock calls. The number returned is from the actual h_address_list[] en}{\f5 tries in the HOSTENT structure returned by gethostbyname()/gethostbyaddr(). 
\par }{\f5 
\par }\pard {\b\f5 Data Type
\par }\pard \li180 {\f5 Array of }{\b\f5 String}{\f5 s
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180\tx3510 {\f5 VB1.0+, VC++ possibly
\par }{\f5 
\par }\pard \tx3510 {\b\f5 \page }{\b\f5\fs22\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_HOSTADDRESSLIST}}{\b\f5\fs22 See also
\par }\pard \li187\tx3510 {\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5 
\par }{\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5 
\par }{\f5\uldb HostAddressCount}{\v\f5 NETCLIENT_PROPERTY_HOSTADDRESSCOUNT}{\f5 
\par }{\f5\uldb HostAliasCount}{\v\f5 NETCLIENT_PROPERTY_HOSTALIASCOUNT}{\f5 
\par }{\f5\uldb HostAliasList}{\v\f5 NETCLIENT_PROPERTY_HOSTALIASLIST}{\f5 
\par }{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_HOSTALIASCOUNT}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient HostAliasCount Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;HostAliasCount}}{\plain \b\f5\lang1033  HostAliasCount Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_HOSTALIASCOUNT}{\f5\fs18 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 This property holds th}{\f5 e current number of elements in the }{\f5\uldb HostAliasList}{\v\f5 NETCLIENT_PROPERTY_HOSTALIASLIST}{\f5  property array. This number signifies the number of I.P. Addresses for a DNS host.
\par }\pard \tx3510 {\b\f5 
\par }\pard {\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 count%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 HostAliasCount}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetNumProperty("HostAliasCount")}{\f5 
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 Setting }{\b\f5 HostAliasCount}{\f5  will return VBERR_WRITEONLY (383).
\par }{\f5 
\par }{\f5 Reading }{\b\f5 HostAliasCount}{\f5  will tell you the number of DNS host strings contained in the }{\f5\uldb HostAliasList()}{\v\f5 NETCLIENT_PROPERTY_HOSTALIASLIST}{\f5  property array. Do }{\f5 
NOT attempt to read past this limit, or you will receive VBERR_BADVBINDEX (381).
\par }\pard \tx3510 {\b\f5 
\par }\pard {\b\f5 WinSock Calls
\par }\pard \li180 {\f5 None. This property calls no actual WinSock calls. The number returned is from the number of h_aliases[] entries in the HOSTENT structure returned by gethostbyname()/gethostbyaddr(). When you set }{\f5\uldb HostAddr}{\v\f5 
NETCLIENT_PROPERTY_HOSTADDR}{\f5  or }{\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5 , this property is set automagically.
\par }{\f5 
\par }\pard {\b\f5 Data Type
\par }\pard \li180 {\b\f5 Integer
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180\tx3510 {\f5 VB1.0+/VC++
\par }\pard \tx3510 {\b\f5 \page }{\b\f5\fs22\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_HOSTALIASCOUNT}}{\b\f5\fs22 See also
\par }\pard \li187\tx3510 {\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5 
\par }{\f5\uldb HostName}{\v\f5 NET}{\v\f5 CLIENT_PROPERTY_HOSTNAME}{\f5 
\par }{\f5\uldb HostAliasList}{\v\f5 NETCLIENT_PROPERTY_HOSTALIASLIST}{\f5 
\par }{\f5\uldb HostAddressCount}{\v\f5 NETCLIENT_PROPERTY_HOSTADDRESSCOUNT}{\f5 
\par }{\f5\uldb HostAddressList}{\v\f5 NETCLIENT_PROPERTY_HOSTADDRESSLIST}{\f5 
\par }\pard \tx3510 {\b\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_HOSTALIASLIST}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient HostAliasList Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;HostAliasList}}{\plain \b\f5\lang1033  HostAliasList Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_HOSTALIASLIST}{\f5\fs18 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 This property array holds the }{\f5\uldb DNS}{\v\f5 POPUP_DNS}{\f5  strings returned via gethostbyname()/gethostbyaddr().
\par }{\f5 
\par }\pard {\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 hostaddr$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 HostAliasList(}{\i\f5 index}{\b\f5 )}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180\brdrt\brdrs\brdrw30\brsp20 \brdrb\brdrs\brdrw30\brsp20 \tx3510 {\f5 I do not know how VC++ uses property array}{\f5 s.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 When you set }{\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5  or }{\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5 , this property is set automagically.
\par }\pard \li180\tx3510 {\f5 
\par }{\f5 This property array holds the h_aliases[] array as returned through the HOSTENT structure by gethostbyname()/gethostbyaddr(). 
\par }{\f5 
\par }{\f5 The number of elements of this array is available through the }{\f5\uldb HostAliasCount}{\v\f5 NETCLIENT_PROPERTY_HOSTALIASCOUNT}{\f5  property. Do NOT attempt to access the }{\b\f5 HostAliasList()}{\f5 
 array past this limit, or you will receive VBERR_BADVBINDEX (381).
\par }{\f5 
\par }{\f5 By u}{\f5 sing the }{\i\f5 index}{\f5  to step through the array, you can find all DNS addresses for a remote host. This helps multi-homed clients and applications that need to know multiple "routes" to a remote host.
\par }{\f5 
\par }\pard {\b\f5 WinSock Calls
\par }\pard \li180 {\f5 None. This property calls no actual WinSock calls. The number returned is from the actual h_aliases[] entries in the HOSTENT structure returned by gethostbyname()/gethostbyaddr(). 
\par }{\f5 
\par }\pard {\b\f5 Data Type
\par }\pard \li180 {\f5 Array of }{\b\f5 String}{\f5 s
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180\tx3510 {\f5 VB1.0+, VC++ possibly
\par }{\f5 
\par }\pard \tx3510 {\b\f5 \page }{\b\f5\fs22\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_HOSTALIASLIST}}{\b\f5\fs22 See also
\par }\pard \li187\tx3510 {\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5 
\par }{\f5\uldb Host}{\f5\uldb Name}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5 
\par }{\f5\uldb HostAliasCount}{\v\f5 NETCLIENT_PROPERTY_HOSTALIASCOUNT}{\f5 
\par }{\f5\uldb HostAddressCount}{\v\f5 NETCLIENT_PROPERTY_HOSTADDRESSCOUNT}{\f5 
\par }{\f5\uldb HostAddressList}{\v\f5 NETCLIENT_PROPERTY_HOSTADDRESSLIST}{\f5 
\par }\pard \tx3510 {\b\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_HOSTNAME}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetClient HostName Property}}
{\fs16\up6 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;HostAddr}}{\plain \b\f5\up6\lang1033  }{\plain \b\f5\lang1033 HostName Property, NetClient Control
\par }\pard \keepn {\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_HOSTNAME}{\f5\fs18 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 This property is used to resolve a }{\f5\ul DNS}{\v\f5 POPUP_DNS}{\f5   name and set the remote host's }{\f5\ul FQDN}{\v\f5 POPUP_FQDN}{\f5  for socket communication. 
\par }{\f5 
\par }\pard {\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 HostName}{\f5 [}{\i\f5 = hostname$}{\f5 ]
\par }{\f5 [}{\i\f5 fullhostname$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 HostName}{\b\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetStrProperty("HostName")}{\f5 
\par }{\f5 pNetClient->}{\b\f5 SetStrProperty("HostName",}{\f5  hostname}{\b\f5 )
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 At run time, this property initially holds the }{\f5\ul FQDN}{\v\f5 POPUP_FQDN}{\f5  of your local host (or "" if your WinSock is substandard).
\par }{\f5 
\par }{\f5 Setting this property to a host name invokes the name resolver. Your program will temporarily block (for often no more than a fraction of a second) while a }{\f5\ul DNS}{\v\f5 POPUP_DNS}{\f5  lookup is made through your local name server or local }{
\i\f5 hosts}{\f5  file on your PC. If an error occurs, this}{\f5  property will be set to a empty string ("") , the }{\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5  property will be set to an empty string ("") and the }{\f5\uldb OnError()}{
\v\f5 NETCLIENT_EVENT_ONERROR}{\f5  event will be called with the appropriate WinSock error. If no error occurs, this property will be set to the }{\f5\ul FQDN}{\v\f5 POPUP_FQDN}{\f5  of the host, and the }{\f5\uldb HostAddr}{\v\f5 
NETCLIENT_PROPERTY_HOSTADDR}{\f5  property will be set to the correct I.P. string for the host.
\par }{\f5 
\par }{\f5 Reading this property will be the result of any previous }{\i\f5 set}{\f5  operation, or your local PC's }{\f5\ul F}{\f5\ul QDN}{\v\f5 POPUP_FQDN}{\f5  if it is the first time you access it.
\par }{\f5 
\par }{\f5 You only need to set  }{\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5  OR }{\b\f5 HostName}{\f5 ; setting both is unnecessarily redundant. After setting one of these properties, the other is set appropriately.
\par }{\f5 
\par }{\f5 If the requested Host is in your WinSock.DLL's database (most likely from a HOSTS  file), no blocking }{\i\f5 should}{\f5 
 be involved - but this seems to be vendor specific. If your vendor's WinSock.DLL does not block as it reads its database, there should be no actual delay as norm}{\f5 al DNS lookups would incur.
\par }{\f5 
\par }{\f5 
\par }\pard \li180\brdrt\brdrdb\brdrw15\brsp20 \brdrb\brdrdb\brdrw15\brsp20 {\f5 Currently, setting this property invokes the corresponding }{\i\f5 blocking}{\f5 
 call of your WinSock. This is not the best way to implement this functionality. A better way would be to add a OnGetHost() event and a HostAsync property. If this were used, WSAAsyncGetHostByName() could be used, and your application would not block. Whi
}{\f5 le your application }{\i\f5 blocks}{\f5 , your application will }{\i\f5 stick}{\f5  until it completes.
\par }\pard {\b\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180 {\f5 inet_ntoa(), gethostbyname()
\par }\pard {\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 String }{\f5 (HSZ)
\par }\pard {\f5 
\par }{\b\f5 Scop}{\b\f5 e
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard {\b\f5\fs22 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_HOSTNAME}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_LINE}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient Line Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;Line}}{\plain \b\f5\lang1033  Line Property, NetClient Control
\par }\pard \keepn {\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_LINE}{\f5\fs18 
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 Sends or receives a }{\b\f5 Line}{\f5  of data from/to a connected Socket.
\par }\pard {\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5 NetClient}{\f5  .}{\b\f5 Line}{\f5 [}{\i\f5 = lineoutput$}{\f5 ]
\par }{\f5 [}{\i\f5 lineinput$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 Line}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetStrProperty("Line")}{\f5 
\par }{\f5 pNetClient->}{\b\f5 SetStrProperty("Line",}{\i\f5  lineoutput$}{\b\f5 )
\par }\pard {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 This property is nothing more than BOTH the }{\f5\uldb SendLine}{\v\f5 NETCLIENT_PROPERTY_SENDLINE}{\f5  and }{\f5\uldb RecvL}{\f5\uldb ine}{\v\f5 NETCLIENT_PROPERTY_RECVLINE}{\f5 
 properties combined into a single property. Setting this property invokes }{\f5\uldb SendLine}{\v\f5 NETCLIENT_PROPERTY_SENDLINE}{\f5 , and getting this property invokes }{\f5\uldb RecvLine}{\v\f5 NETCLIENT_PROPERTY_RECVLINE}{\f5 .
\par }\pard {\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180 {\f5 See the }{\f5\uldb RecvLine}{\v\f5 NETCLIENT_PROPERTY_RECVLINE}{\f5 , }{\f5\uldb SendLine}{\v\f5 NETCLIENT_PROPERTY_SENDLINE}{\f5 , and }{\f5\uldb LineDelimiter}{\v\f5 NETCLIENT_PROPERTY_LINEDELIMITER}{\f5  properties.
\par }\pard {\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 String}{\f5  (HSZ)
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard {\b\f5\fs22 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_LINE}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb RecvLine}{\v\f5 NETCLIENT_PROPERTY_RECVLINE}{\f5 
\par }{\f5\uldb LineDelimiter}{\v\f5 NETCLIENT_PROPERTY_LINEDE}{\v\f5 LIMITER}{\f5 
\par }{\f5\uldb SendLine}{\v\f5 NETCLIENT_PROPERTY_SENDLINE}{\f5 
\par }\pard \keepn {\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_LINEDELIMITER}}{\plain \b\f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient LineDelimiter Property}}{\plain \b\f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;LineDelimiter}}{\plain \b\f5\lang1033  LineDelimiter Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_LINEDELIMITER}{\f5\fs18 
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 This property is tied to the functionality of the RecvLine property and determines the end-of-line marker for incoming data.
\par }\pard {\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5 NetClient}{\f5  .}{\b\f5 LineDelimiter}{\f5 [}{\i\f5 = eol$}{\f5 ]
\par }{\f5 [}{\i\f5 eol$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 LineDelimiter}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetStrProperty("LineDelimiter")}{\f5 
\par }{\f5 pNetClient->}{\b\f5 SetStrProperty("LineDelimiter",}{\i\f5  eol$}{\b\f5 )
\par }\pard {\f5 
\par }\pard \tx3510 {\b\f5 Remarks
\par }\pard \li180\tx720\tx3510 {\f5 The }{\b\f5 LineDe}{\b\f5 limiter}{\f5  property is used to specify the end-of-line character sequence for incoming data accessed through the }{\f5\uldb RecvLine}{\v\f5 NETCLIENT_PROPERTY_RECVLINE}{\f5 
 property. When set to a non-empty sequence of characters (except Chr$(0)), this property dictates what can be seen in the }{\f5\uldb RecvLine}{\v\f5 NETCLIENT_PROPERTY_RECVLINE}{\f5  property. When an application accesses the }{\f5\uldb RecvLine}{\v\f5 
NETCLIENT_PROPERTY_RECVLINE}{\f5  property, the incoming receive buffer is scanned for the character sequence in the }{\b\f5 LineDelimiter}{\f5  property and any if the sequence}{\f5 
 is found, the stream preceeding the end-of-line sequence is returned. The end-of-line sequence, when and if found, }{\i\f5 DOES NOT}{\f5  appear at the end of any data received from the }{\f5\uldb RecvLine}{\v\f5 NETCLIENT_PROPERTY_RECVLINE}{\f5 
 property.
\par }{\f5 \tab 
\par }{\f5 When }{\b\f5 LineDelimiter}{\f5  is set to an empty string (""), the }{\f5\uldb RecvLine}{\v\f5 NETCLIENT_PROPERTY_RECVLINE}{\f5  property will return the entire incoming buffer.
\par }\pard \li180\tx3510 {\f5 
\par }{\f5 An example use of the }{\b\f5 LineDelimiter}{\f5  property might be:
\par }\pard \qc\li180\tx3510 {\b\f5 
\par }{\f7 NetClient(0).}{\b\f7 LineDelimiter }{\f7\cf2 = Chr$(}{\f7 13}{\f7\cf2 ) + Chr$(}{\f7 10}{\f7\cf2 )}{\b\f7\cf2 
\par }\pard \li180\tx3510 {\f5 
\par }\pard \li180\tx720\tx3510 {\f5 This would set up any reads from Rec}{\f5 
vLine to return incoming lines that are terminated by a Carriage Return and Line Feed sequence, respectively. This would be the appropriate setting for talking to another DOS host, or protocol such as SMTP which specifies both characters as a end-of-line 
}{\f5 marker. On most Unix style servers, the default end-of-line sequence is Chr$(10) ("\\n"). 
\par }\pard \li180\tx3510 {\f5 
\par }{\f5 Translated sequences (for C programmer's convenience):
\par }\trowd \trgaph108\trleft612 \cellx1422\cellx3162\cellx4947\cellx7047\pard \intbl {\b\f5 String\cell }{\b\f5 VB Equivalent\cell }{\b\f5 ASCII meaning\cell }{\b\f5 ASCII "Keystroke"\cell }\pard \intbl {\b\f5 \row }\trowd \trgaph108\trleft612 \cellx1422
\cellx3162\cellx4947\cellx7047\pard \intbl {\f5 "\\n"\cell }{\f5 Chr$(10)\cell }{\f5 Linefeed\cell }{\f5 Control J\cell }\pard \intbl {\f5 \row }\pard \intbl {\f5 "\\r"\cell }{\f5 Chr$}{\f5 (13)\cell }{\f5 Carriage Return\cell }{\f5 Control M\cell }\pard 
\intbl {\f5 \row }\trowd \trgaph108\trleft612 \cellx1422\cellx3162\cellx4947\cellx7047\pard \intbl {\f5 "\\t"\cell }{\f5 Chr$(8)\cell }{\f5 Horizontal Tab\cell }{\f5 Control H\cell }\pard \intbl {\f5 \row }\pard \tx3510 {\b\f5 
\par }\pard \li180\tx3510 {\f5 Please consult the }{\f5\uldb RecvLine}{\v\f5 NETCLIENT_PROPERTY_RECVLINE}{\f5  and }{\f5\uldb Line}{\v\f5 NETCLIENT_PROPERTY_LINE}{\f5  properties for more information.
\par }\pard \tx3510 {\b\f5 
\par }\pard \fi-810\li990\brdrt\brdrs\brdrw30\brsp20 \brdrb\brdrs\brdrw30\brsp20 \tx3510 {\b\f5 NOTE: }{\f5 
Due to the nature of this property, it may NOT contain an embedded NULL character (Chr$(0)). If your data depends on binary data, you will have to use the }{\f5\uldb Block}{\v\f5 NETCLIENT_PROPERTY_BLOCK}{\f5 /}{\f5\uldb RecvBlock}{\v\f5 
NETCLIENT_PROPERTY_RECVBLOCK}{\f5 /}{\f5\uldb SendBlock}{\v\f5 NETCLIENT_PROPERTY_SENDBLOCK}{\f5  properties.
\par }\pard \tx3510 {\b\f5 
\par }\pard {\b\f5 Data Type
\par }\pard \li180 {\b\f5 String}{\f5  (HSZ)
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard {\b\f5\fs22 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_LINEDELIMITER}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb RecvLine}{\v\f5 NETCLIENT_PROPERTY_RECVLINE}{\f5 
\par }\pard \li180\tx3510 {\f5\uldb Line}{\v\f5 NETCLIENT_PROPERTY_LINE}{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_LOCALPORT}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient LocalPort Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;Thanks;LocalPort}}{\plain \b\f5\lang1033  LocalPort Property, NetClient Control
\par }\pard \keepn\tx1440\tx3510 {\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_LOCALPORT}{\f5\fs18 \tab }{\f5\fs18\uldb Thanks}{\v\f5\fs18 TOPIC_THANKS}{\f5\fs18 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 The }{\b\f5 LocalPort}{\f5  property is used to set the local port number for a TCP connection.
\par }\pard \tx3510 {\b\f5 
\par }\pard {\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 LocalPort}{\f5 [}{\i\f5 = port%}{\f5 ]
\par }{\f5 [}{\i\f5 port%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 LocalPort}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetNumProperty("LocalPort")}{\f5 
\par }{\f5 pNetClient->}{\b\f5 SetNumProperty("LocalPort",}{\f5  }{\i\f5 port%}{\b\f5 )
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 T}{\f5 
his property denotes the local port for the TCP connection to a remote port. Some TCP daemons will only accept connections from programs that are locally bound to a port below 1023. In order to make your application compliant to such restrictions, you sho
}{\f5 uld loop backwards from 1023 to 512 in order to allocate a unique }{\i\f5 restricted}{\f5  port.
\par }{\f5 
\par }{\f5 The idea of }{\i\f5 restricted}{\f5  ports stems from }{\f5\ul BSD}{\v\f5 POPUP_BSD}{\f5  Unix, where an application must run as root in order to bind() to a port below 1023. Setting this property to 0 will a}{\f5 
llow the WinSock.DLL to bind the local port to a unique port between 1023 and 5000. This functionality is accomplished by not calling bind() at connect() time.
\par }{\f5 
\par }{\f5 Here is a portion of code from a fictitious RSH server that allocates a }{\i\f5 restricted}{\f5  port:
\par }\pard {\f5 
\par }\pard \li540 {\f7\cf2 On Error Resume Next
\par }{\f7 
\par }{\f7 NetClient.}{\f7\uldb RemotePort}{\v\f7 NETCLIENT_PROPERTY_REMOTEPORT}{\f7  }{\f7\cf2 =}{\f7  512
\par }{\f7 iPort }{\f7\cf2 =}{\f7  1023
\par }{\f7 
\par }{\f7\cf2 Do
\par }\pard \li990 {\f7 NetClient.}{\b\f7 LocalPort}{\f7  }{\f7\cf2 =}{\f7  1023
\par }{\f7 NetClient.}{\f7\uldb ErrorNumber}{\v\f7 NETCLIENT_PROPERTY_ERRORNUMBER}{\f7  }{\f7\cf2 = 0\tab }{\f7\cf11 ' Clear ErrorNumber
\par }{\f7 NetClient.}{\f7\uldb Connect}{\v\f7 NETCLIENT_PROPERTY_CONNECT}{\f7  }{\f7\cf2 =}{\f7  True}{\f7 
\par }{\f7\cf2 If}{\f7  NetClient.}{\f7\uldb ErrorNumber}{\v\f7 NETCLIENT_PROPERTY_ERRORNUMBER}{\f7  }{\f7\cf2 =}{\f7  0 }{\f7\cf2 Then Exit Sub
\par }{\f7 NetClient.}{\f7\uldb ErrorNumber}{\v\f7 NETCLIENT_PROPERTY_ERRORNUMBER}{\f7  = 0
\par }{\f7 iPort }{\f7\cf2 =}{\f7  iPort }{\f7\cf2 -}{\f7  1
\par }{\f7\cf2 If}{\f7  iPort }{\f7\cf2 =}{\f7  512 }{\f7\cf2 Then}{\f7 
\par }\pard \li1530 {\f7 TextTTY }{\f7\cf2 =}{\f7  "Error! Ran out of reserved ports to bind to!"
\par }{\f7\cf2 Exit Sub
\par }\pard \li990 {\f7\cf2 End If
\par }{\f7\cf2 DoEvents
\par }\pard \li540 {\f7\cf2 Loop
\par }\pard \tx3510 {\b\f5 
\par }\pard \li180\brdrt\brdrs\brdrw30\brsp20 \brdrb\brdrs\brdrw30\brsp20 \tx3510 {\b\f5 Note:}{\f5  If you are not using reserved ports for your client, you should set this property to 0 to allow dynamic port allocation.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180\tx3510 {\f5 This property is used at connect() time. See the }{\f5\uldb Connect}{\v\f5 NETCLIENT_PROPERTY_CONNECT}{\f5  property for more }{\f5 information.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180\tx3510 {\b\f5 Integer
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Scope
\par }\pard \li180\tx3510 {\f5 VB1.0+/VC++
\par }\pard {\b\f5\fs22 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_LOCALPORT}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb LocalService}{\v\f5 NETCLIENT_PROPERTY_LOCALSERVICE}{\f5\uldb 
\par }{\f5\uldb RemotePort}{\v\f5 NETCLIENT_PROPERTY_REMOTEPORT}{\f5 
\par }{\f5\uldb HostName}{\v\f5 NETCLIENT_PROPERTY_HOSTNAME}{\f5 
\par }{\f5\uldb HostAddr}{\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5 
\par }{\f5\uldb Connect}{\v\f5 NETCLIENT_PROPERTY_CONNECT}{\f5 
\par }\pard \keepn\tx3510 {\fs16\up6 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_LOCALSERVICE}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetClient LocalService Property}}{\fs16\up6 K
{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;LocalService}}{\b\f5  }{\plain \b\f5\lang1033 LocalService Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_LOCALSERVICE}{\b\f5 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 This property allows an application to use the getservbyXXX() database services. By using this property, you allow the user to merely modify }{\f5 
their TCP/IP's stack in order to use the port that your application uses for the local client port binding. 
\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5 NetClient}{\f5  .}{\b\f5 LocalService}{\f5 [}{\i\f5 = name$}{\f5 ]
\par }{\f5 [}{\i\f5 name$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 LocalService}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetStrProperty("LocalService")}{\f5 
\par }{\f5 pNetClient->}{\b\f5 SetStrProperty("LocalService",}{\i\f5  name$}{\b\f5 )
\par }\pard {\f5 
\par }\pard \tx3510 {\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 This property is not as useful as the }{\f5\uldb RemoteService}{\v\f5 NETCLIENT_PROPERTY_REMOTESERVICE}{\f5  property in that you will probably never need to allow the user to set the local client port bind}{\f5 
ing. If you need to use reserved ports, which is the only real reason for using this or the }{\f5\uldb LocalPort}{\v\f5 NETCLIENT_PROPERTY_LOCALPORT}{\f5 
 property, you will probably need to loop within a range of reserved ports - not use a hard set value from your PC's }{\i\f5 Service}{\f5  database.
\par }\pard \tx3510 {\b\f5 
\par }\pard \li180\tx3510 {\f5 This property is used instead of the }{\f5\uldb LocalPort}{\v\f5 NETCLIENT_PROPERTY_LOCALPORT}{\f5  property in order to set the }{\i\f5 Service name}{\f5  for the local port.
\par }{\f5 
\par }{\f5 When set, this property calls getservbyname() and sets }{\f5\uldb LocalPort}{\v\f5 NETCLIENT_PROPERTY_LOCALPORT}{\f5  to the corre}{\f5 sponding integer port number.
\par }{\f5 
\par }{\f5 When you get this properties' value it calls getservbyport() and returns the appropriate }{\i\f5 Service name}{\f5  for the }{\f5\uldb LocalPort}{\v\f5 NETCLIENT_PROPERTY_LOCALPORT}{\f5  property.
\par }{\f5 
\par }{\f5 When you either set or get this property, check it for an empty string (""). When the }{\i\f5 Service}{\f5  database lookup fails with a NULL pointer, this property will be set to "", and }{\f5\uldb LocalPort}{\v\f5 NETCLIENT_PROPERTY_LOCALPORT}{
\f5  will be set to 0.
\par }{\f5 
\par }{\f5 Some Vendors' WinSock.DLLs will appropriately block if the "Services" database is not}{\f5 
 held locally. Most Vendors implement their WinSock.DLLs in a non-blocking manner, but to do the opposite is quite within the WinSock v1.1 specification; thus, you may have a perceptible delay when this property is accessed. 
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180\tx3510 {\f5 getservbyname(), getservbyport()
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180\tx3510 {\b\f5 String }{\f5 (HSZ)
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Scope
\par }\pard \li180\tx3510 {\f5 VB1.0+/VC++
\par }\pard {\b\f5 \page }{\b\f5\fs22 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_LOCALSERVICE}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb LocalPort}{\v\f5 NETCLIENT_PROPERTY_LOCALPORT}{\f5 
\par }{\f5\uldb RemotePort}{\v\f5 NETCLIENT_PROPERTY_REMOTEPORT}{\f5\uldb 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\fs16\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_RECVBLOCK}}{\fs16\up6 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetClient RecvBlock property}}{\fs16\up6 K
{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;RecvBlock}}{\b\f5  }{\plain \b\f5\lang1033 RecvBlock Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_RECVBLOCK}{\b\f5 
\par }\pard \tx3510 {\b\f5 Descri}{\b\f5 ption
\par }\pard \li180 {\b\f5 RecvBlock}{\f5  allows an application to talk in pure binary to a remote host.}{\b\f5 
\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 message$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 RecvBlock}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 Visual C++ cannot Access Visual Basic strings. (HLSTR is implemented as a property only in VB2.00+) Consult the }{\f5\uldb NetClientSendBlock()}{\v\f5 EXPORT_NETCLIENTSENDBLOCK}{\f5  and }{\f5\uldb NetClientRecvBlock()}{\v\f5 
EXPORT_NETCLIENTRECVBLOCK}{\f5  DLL function exports for more information.
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\b\f5 RecvBlock}{\f5  uses the newer HLSTR property type (introduced in VB2.00+). Unlike the }{\f5\uldb RecvLine}{\v\f5 NETCLI}{\v\f5 ENT_PROPERTY_RECVLINE}{\f5  property with }{\f5\uldb LineDelimiter}{\v\f5 NETCLIENT_PROPERTY_LINEDELIMITER
}{\f5  set to "", embedded Null characters (Chr$(0)) is permitted.
\par }{\f5 
\par }{\b\f5 RecvBlock}{\f5  will return whatever is in the receive buffer as a VB string.
\par }{\f5 
\par }{\f5 Visual C++ does NOT implement the HLSTR type as a property, so it must use the functions }{\f5\uldb NetClientSendBlock()}{\v\f5 EXPORT_NETCLIENTSENDBLOCK}{\f5  and }{\f5\uldb NetClientRecvBlock()}{\v\f5 EXPORT_NETCLIENTRECVBLOCK}{\f5 
 that are exported from the VBX itself (as a VBX is nothing more than a DLL).
\par }\pard {\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180 {\f5 None. This p}{\f5 
roperty calls no actual WinSock calls. The recv() call is used during an FD_READ event generated to the control window via WSAAsyncSelect(), and the data is buffered to be returned through this property on demand (usually in response to a }{\f5\uldb 
OnRecv()}{\v\f5 NETCLIENT_EVENT_ONRECV}{\f5  event).
\par }\pard {\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 String}{\f5  (HLSTR)
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180\tx3510 {\f5 VB2.0+
\par }\pard {\b\f5 \page }{\b\f5\fs22 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_RECVBLOCK}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb Block}{\v\f5 NETCLIENT_PROPERTY_BLOCK}{\f5\uldb 
\par }{\f5\uldb SendBlock}{\v\f5 NETCLIENT_PROPERTY_SENDBLOCK}{\f5\uldb 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_RECVCOUNT}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient RecvCount Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;RecvCount}}{\plain \b\f5\lang1033  RecvCount Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_RECVCOUNT}{\b\f5 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 This }{\f5 property holds the current number of bytes awaiting processing in the Receive }{\f5\ul FIFO}{\v\f5 POPUP_FIFO}{\f5  buffer.
\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 count%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 RecvCount}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetNumProperty("RecvCount")}{\f5 
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 Setting }{\b\f5 RecvCount}{\f5  has no effect.
\par }{\f5 
\par }{\f5 This property changes as bytes are received on a connected socket. If the number of bytes received exceed the limit in }{\f5\uldb RecvThreshold}{\v\f5 NETCLIENT_PROPERTY_RECVTHRESHOLD}{\f5 , the }{\f5\uldb OnRecv()}{\v\f5 NETCLIENT_EVENT_ONRECV}{
\f5  event is fired. If }{\f5\uldb RecvThreshold}{\v\f5 NETCLIENT_PROPERTY}{\v\f5 _RECVTHRESHOLD}{\f5  is 0, }{\f5\uldb OnRecv()}{\v\f5 NETCLIENT_EVENT_ONRECV}{\f5  will be fired whenever more incoming bytes are received.
\par }\pard \tx3510 {\b\f5 
\par }\pard {\b\f5 WinSock Calls
\par }\pard \li180 {\f5 None. This property calls no actual WinSock calls. The recv() call is used during an FD_READ event generated to the control window via WSAAsyncSelect(), and the data is buffered to be returned on demand (usually in response to a }{
\f5\uldb OnRecv()}{\v\f5 NETCLIENT_EVENT_ONRECV}{\f5  event). This property merely reports the current number of characters in the receive buffer.
\par }\pard {\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 Integer
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180\tx3510 {\f5 VB1.0+/VC++
\par }\pard {\b\f5 \page }{\b\f5\fs22 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_RECVCOUNT}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb SendCount}{\v\f5 NETCLIENT_PROPERTY_SENDCOUNT}{\f5\uldb 
\par }{\f5\uldb RecvSize}{\v\f5 NETCLIENT_PROPERTY_RECVSIZE}{\f5\uldb 
\par }{\f5\uldb SendSize}{\v\f5 NETCLIENT_PROPERTY_SENDSIZE}{\f5 
\par }{\f5\uldb RecvThreshold}{\v\f5 NETCLIENT_PROPERTY_RECVTHRESHOLD}{\f5\uldb 
\par }{\f5\uldb SendThreshold}{\v\f5 NETCLIENT_PROPERTY_SENDTHRESHOLD}{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_RECVLINE}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient RecvLine Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;RecvLine}}{\plain \b\f5\lang1033  RecvLine Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_RECVLINE}{\b\f5 
\par }\pard {\b\f5 Description
\par }\pard \li180 {\f5 Receives a line of data from a connected Socket.
\par }\pard {\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 lineinput$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 RecvLine}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetStrProperty("RecvLine")}{\f5 
\par }\pard {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 This pr}{\f5 operty receives a single line of data from the receive buffer. The end-of-line sequence should first be specified through the }{\f5\uldb LineDelimiter}{\v\f5 NETCLIENT_PROPERTY_LINEDELIMITER}{\f5 
 property in order for this property to only return a line at a time. If the }{\f5\uldb LineDelimiter}{\v\f5 NETCLIENT_PROPERTY_LINEDELIMITER}{\f5 
 property is set to an empty string (""), then this property will return all non-null characters from the buffer. If you need to receive binary data, you should use the }{\f5\uldb Block}{\v\f5 NETCLIENT_PROPERTY_BLOCK}{\f5 /}{\f5\uldb RecvBlock}{\v\f5 
NETCLIENT_P}{\v\f5 ROPERTY_RECVBLOCK}{\f5 /}{\f5\uldb SendBlock}{\v\f5 NETCLIENT_PROPERTY_SENDBLOCK}{\f5  properties or NetClientSendData()/NetClientRecvData().
\par }{\f5 
\par }{\f5 If you have set the }{\f5\uldb LineDelimiter}{\v\f5 NETCLIENT_PROPERTY_LINEDELIMITER}{\f5 
 property to a non empty string, you should set up a loop in your program to handle any other lines that might have been received as well. Your application should make sure that }{\b\f5 RecvLine}{\f5 
 returns an empty string before proceeding, unless it is prepared to handle the received data out of the }{\f5\uldb OnRecv()}{\v\f5 NETCLIENT_EVENT_ONRECV}{\f5  event.
\par }\pard {\f5 
\par }{\b\f5 W}{\b\f5 inSock Calls
\par }\pard \li180 {\f5 
None. This property calls no actual WinSock calls. The recv() call is used during an FD_READ event generated to the control window via WSAAsyncSelect(), and the data is buffered to be returned through this property on demand (usually in response to a }{
\f5\uldb OnRecv()}{\v\f5 NETCLIENT_EVENT_ONRECV}{\f5  event).
\par }\pard {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 String}{\f5  (HSZ)
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }{\f5 VB1.0+/VC++
\par }{\b\f5 \page }{\b\f5\fs22 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_RECVLINE}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb RecvThreshold}{\v\f5 NETCLIENT_PROPERTY_RECVTHRESHOLD}{\f5 
\par }{\f5\uldb SendLine}{\v\f5 NETCLIENT_PROPERTY_SENDLINE}{\f5 
\par }{\f5\uldb Line}{\v\f5 NETCLIENT_PROPERTY_LINE}{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_RECVSIZE}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient RecvSize Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;RecvSize}}{\plain \b\f5\lang1033  RecvSize Property, NetClient}{\plain \b\f5\lang1033  Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_RECVSIZE}{\b\f5 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 The }{\b\f5 RecvSize}{\f5  property is used to set size of the receive }{\f5\ul FIFO}{\v\f5 POPUP_FIFO}{\f5  buffer.
\par }\pard \tx3510 {\b\f5 
\par }\pard {\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 RecvSize}{\f5 [}{\i\f5 = size%}{\f5 ]
\par }{\f5 [}{\i\f5 size%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 RecvSize}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetNumProperty("RecvSize")}{\f5 
\par }{\f5 pNetClient->}{\b\f5 SetNumProperty("RecvSize",}{\f5  }{\i\f5 size%}{\b\f5 )
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 By default, this property holds the value returned by a getsockopt() call for SO_RCVBUF immediately before an }{\f5\uldb OnConnect()}{\v\f5 NETCLIENT_EVENT_ONCONNECT}{\f5  event, or a sa}{\f5 
ved value from design time, which ever is greater.
\par }{\f5 
\par }{\f5 Setting this property will force the NetClient control to TRY and resize the receive }{\f5\ul FIFO}{\v\f5 POPUP_FIFO}{\f5  buffer size to size specified. 
\par }{\f5 
\par }{\f5 Getting this property will return the CURRENT size of the receive }{\f5\ul FIFO}{\v\f5 POPUP_FIFO}{\f5  buffer.
\par }{\f5 
\par }\pard {\b\f5 WinSock Calls
\par }\pard \li180 {\f5 If there is data in the receive buffer, the }{\f5\uldb OnRecv()}{\v\f5 NETCLIENT_EVENT_ONRECV}{\f5 
 event will be fired in order to let the application attempt to parse the data. If the receive buffer is then empty, or was empty initially em}{\f5 pty, the Global buffer is reallocated.
\par }\pard {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 Integer}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard {\b\f5\fs22 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_RECVSIZE}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb SendSize}{\v\f5 NETCLIENT_PROPERTY_SENDSIZE}{\f5\uldb 
\par }{\f5\uldb SendCount}{\v\f5 NETCLIENT_PROPERTY_RECVCOUNT}{\f5\uldb 
\par }{\f5\uldb RecvCount}{\v\f5 NETCLIENT_PROPERTY_RECVCOUNT}{\f5 
\par }\pard \li187 {\f5\uldb RecvThreshold}{\v\f5 NETCLIENT_PROPERTY_RECVTHRESHOLD}{\f5\uldb 
\par }{\f5\uldb SendThreshold}{\v\f5 NETCLIENT_PROPERTY_SENDTHRESHOLD}{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_RECVTHRESHOLD}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient RecvThreshold Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;RecvThreshold}}{\plain \b\f5\lang1033  RecvThreshold Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_RECVTHRESHOLD}{\b\f5 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 This property specifies how many characters are allowed to be queued in the receive buffer before t}{\f5 he }{\f5\uldb OnRecv()}{\v\f5 NETCLIENT_EVENT_ONRECV}{\f5  event is fired.
\par }{\f5 
\par }\pard {\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 RecvThreshold}{\f5 [}{\i\f5 = size%}{\f5 ]
\par }{\f5 [}{\i\f5 size%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 RecvThreshold}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetNumProperty("RecvThreshold")}{\f5 
\par }{\f5 pNetClient->}{\b\f5 SetNumProperty("RecvThreshold",}{\f5  }{\i\f5 size%}{\b\f5 )
\par }\pard \tx3510 {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 By default, this property is set to 0. This means that every FD_READ message will result in a }{\f5\uldb OnRecv()}{\v\f5 NETCLIENT_EVENT_ONRECV}{\f5  event if characters are received.
\par }{\f5 
\par }{\f5 This property can be set to any value in order to allow your application t}{\f5 o cut down on the number of }{\f5\uldb OnRecv()}{\v\f5 NETCLIENT_EVENT_ONRECV}{\f5  events that it received. 
\par }{\f5 
\par }{\f5 This property is of enormous use to those programs that send and expect large }{\i\f5 chunks}{\f5 
 of data. If your minimum transmission size is 64k, you wouldn't need to handle mere 512 byte packets at a time. By setting this property to the smallest aggregate transmission size, you allow the network control to receive a number of incoming stream fra
}{\f5 gments without waiting for an }{\f5\uldb OnRecv()}{\v\f5 NETCLIENT_EVENT_ONRECV}{\f5  event to finish.
\par }\pard {\b\f5 
\par }{\b\f5 WinS}{\b\f5 ock Calls
\par }\pard \li180 {\f5 None.
\par }\pard {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 Integer
\par }\pard {\b\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard {\b\f5\fs22 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_RECVTHRESHOLD}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb SendThreshold}{\v\f5 NETCLIENT_PROPERTY_SENDTHRESHOLD}{\f5 
\par }{\f5\uldb SendSize}{\v\f5 NETCLIENT_PROPERTY_SENDSIZE}{\f5\uldb 
\par }{\f5\uldb RecvSize}{\v\f5 NETCLIENT_PROPERTY_RECVSIZE}{\f5\uldb 
\par }{\f5\uldb SendCount}{\v\f5 NETCLIENT_PROPERTY_RECVCOUNT}{\f5\uldb 
\par }{\f5\uldb RecvCount}{\v\f5 NETCLIENT_PROPERTY_RECVCOUNT}{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_REMOTEPORT}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient RemotePort Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;RemotePort}}{\plain \b\f5\lang1033  RemotePort Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_REMOTEPORT}{\b\f5 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 The }{\b\f5 RemotePort}{\f5  property is used to set the remote port number for a TCP connection.
\par }\pard \tx3510 {\b\f5 
\par }\pard {\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 RemotePort}{\f5 [}{\i\f5 = port}{\i\f5 %}{\f5 ]
\par }{\f5 [}{\i\f5 port%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 RemotePort}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetNumProperty("RemotePort")}{\f5 
\par }{\f5 pNetClient->}{\b\f5 SetNumProperty("RemotePort",}{\f5  }{\i\f5 port%}{\b\f5 )
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\f5 This property denotes the remote port for the TCP connection to a remote host. The }{\b\f5 RemotePort}{\f5  is specified at }{\f5\uldb Connect}{\v\f5 NETCLIENT_PROPERTY_CONNECT}{\f5 
 time, after which it may NOT be changed during a connection.
\par }\pard \li180\tx3510 {\f5 
\par }{\f5 This property MUST be set either directly, or through the }{\f5\uldb RemoteService}{\v\f5 NETCLIENT_PROPERTY_REMOTESERVICE}{\f5  property, before a remote connection ca}{\f5 n occur.
\par }{\f5 
\par }{\f5 You may also want to specify the }{\f5\uldb LocalPort}{\v\f5 NETCLIENT_PROPERTY_LOCALPORT}{\f5  property if your application is acting as a restricted port client.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180\tx3510 {\f5 This property is used at connect() time. See the }{\f5\uldb Connect}{\v\f5 NETCLIENT_PROPERTY_CONNECT}{\f5  property for more information.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180\tx3510 {\b\f5 Integer
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Scope
\par }\pard \li180\tx3510 {\f5 VB1.0+/VC++
\par }\pard {\b\f5\fs22 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_REMOTEPORT}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb LocalPort}{\v\f5 NETCLIENT_PROPERTY_LOCALPORT}{\f5 
\par }{\f5\uldb RemoteService}{\v\f5 NETCLIENT_PROPERTY_REMOTESERVICE}{\f5\uldb 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_REMOTESERVICE}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient RemoteService Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;RemoteService}}{\plain \b\f5\lang1033  RemoteService Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_REMOTE}{\v\f5\fs18 SERVICE}{\b\f5 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 This property allows an application to use the getservbyXXX() database services. By using this property, you allow the user to merely modify their TCP/IP's stack in order to use the port that your application uses for the }{
\f5\uldb RemotePort}{\v\f5 NETCLIENT_PROPERTY_REMOTEPORT}{\f5  binding. 
\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5 NetClient}{\f5  .}{\b\f5 RemoteService}{\f5 [}{\i\f5 = name$}{\f5 ]
\par }{\f5 [}{\i\f5 name$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 RemoteService}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetStrProperty("RemoteService")}{\f5 
\par }{\f5 pNetClient->}{\b\f5 SetStrProperty("RemoteService",}{\i\f5  name$}{\b\f5 )
\par }\pard {\f5 
\par }\pard \tx3510 {\b\f5 R}{\b\f5 emarks
\par }\pard \li180\tx3510 {\f5 This property is used instead of the }{\f5\uldb RemotePort}{\v\f5 NETCLIENT_PROPERTY_REMOTEPORT}{\f5  property in order to set the }{\i\f5 Service name}{\f5  for the remote port.
\par }{\f5 
\par }{\f5 When set, this property calls getservbyname() and sets }{\f5\uldb RemotePort}{\v\f5 NETCLIENT_PROPERTY_REMOTEPORT}{\f5  to the corresponding integer port number.
\par }{\f5 
\par }{\f5 When you get this properties' value it calls getservbyport() and returns the appropriate }{\i\f5 Service name}{\f5  for the }{\f5\uldb RemotePort}{\v\f5 NETCLIENT_PROPERTY_REMOTEPORT}{\f5  property.
\par }{\f5 
\par }{\f5 When you either set or get this property, check it for an }{\f5 empty string (""). When the }{\i\f5 Service}{\f5  database lookup fails with a NULL pointer, this property will be set to "", and }{\f5\uldb RemotePort}{\v\f5 
NETCLIENT_PROPERTY_REMOTEPORT}{\f5  will be set to 0. 
\par }{\f5 
\par }{\f5 
Some Vendors' WinSock.DLLs will appropriately block if the "Services" database is not held locally. Most Vendors implement their WinSock.DLLs in a non-blocking manner, but to do the opposite is quite within the WinSock v1.1 specification; thus, you may ha
}{\f5 ve a perceptible delay when this property is accessed. 
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180\tx3510 {\f5 getse}{\f5 rvbyname(), getservbyport()
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180\tx3510 {\b\f5 String }{\f5 (HSZ)
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Scope
\par }\pard \li180\tx3510 {\f5 VB1.0+/VC++
\par }\pard {\b\f5 \page }{\b\f5\fs22 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_REMOTESERVICE}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb LocalPort}{\v\f5 NETCLIENT_PROPERTY_LOCALPORT}{\f5 
\par }{\f5\uldb RemotePort}{\v\f5 NETCLIENT_PROPERTY_REMOTEPORT}{\f5\uldb 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_SENDBLOCK}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient SendBlock Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;SendBlock}}{\plain \b\f5\lang1033 SendBlock Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_SENDBLOCK}{\b\f5 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180 {\b\f5 SendBlock}{\f5  allows an application to talk in pure binary to a remote host.}{\b\f5 
\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 SendBlock}{\i\f5  =}{\f5 [}{\i\f5 block$}{\f5 ]
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 Visual C++ cannot access Visual Basic strings. (HLSTR is implemented as a property only in VB2.00+)}{\f5  Consult the }{\f5\uldb NetClientSendBlock()}{\v\f5 EXPORT_NETCLIENTSENDBLOCK}{\f5  and }{\f5\uldb NetClientRecvBlock()}{\v\f5 
EXPORT_NETCLIENTRECVBLOCK}{\f5  DLL function exports for more information.
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\b\f5 SendBlock}{\f5  uses the newer HLSTR property type (introduced in VB2.00+). Unlike the }{\f5\uldb SendLine}{\v\f5 NETCLIENT_PROPERTY_SENDLINE}{\f5 
 property with LineDelimiter set to "", embedded Null characters (Chr$(0)) is permitted.
\par }{\f5 
\par }{\b\f5 SendBlock}{\f5  will put whatever is handed to it as a VB string into in the send buffer.
\par }{\f5 
\par }{\f5 Visual C++ does }{\i\f5 NOT}{\f5  implement the HLSTR type as a pro}{\f5 perty, so it must use the functions }{\f5\uldb NetClientSendBlock()}{\v\f5 EXPORT_NETCLIENTSENDBLOCK}{\f5  and }{\f5\uldb NetClientRecvBlock()}{\v\f5 EXPORT_NETCLIENTRECVBLOCK}
{\f5  that are exported from the VBX itself (as a VBX is nothing more than a DLL).
\par }\pard {\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180 {\f5 This property calls send() until either:
\par }\pard \li360 {\b\f5 1)}{\f5  All of the handed data is accepted by the WinSock.DLL
\par }{\b\f5 2)}{\f5  The send() call returns WSAEWOULDBLOCK
\par }\pard \li180 {\f5 In the second case, a flag is set so that no more send attempts are made until an FD_WRITE message is posted to the control's window by the Wi}{\f5 
nSock.DLL. When this message is posted, the flag is cleared, and an attempt at sending unsent data is attempted.
\par }\pard {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 String}{\f5  (HLSTR)
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180\tx3510 {\f5 VB2.0+
\par }\pard {\b\f5 \page }{\b\f5\fs22 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_SENDBLOCK}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb RecvBlock}{\v\f5 NETCLIENT_PROPERTY_RECVBLOCK}{\f5 
\par }{\f5\uldb Block}{\v\f5 NETCLIENT_PROPERTY_BLOCK}{\f5\uldb 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_SENDCOUNT}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient SendCount Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;SendCount}}{\plain \b\f5\lang1033 SendCount Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_SENDCOUNT}{\b\f5 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 This property holds the current number of bytes waiting to be sent in the Send }{\f5\ul FIFO}{\v\f5 POPUP_FIFO}{\f5  buffer.
\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 count%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 SendCount}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C+}{\b\f5 +
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetNumProperty("SendCount")}{\f5 
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 Setting }{\b\f5 SendCount}{\f5  has no effect.
\par }{\f5 
\par }{\f5 This property changes as bytes are sent to a connected socket. If the number of bytes sent reach the limit in }{\f5\uldb SendThreshold}{\v\f5 NETCLIENT_PROPERTY_SENDTHRESHOLD}{\f5 , the }{\f5\uldb OnSend()}{\v\f5 NETCLIENT_EVENT_ONSEND}{\f5 
 event is fired. 
\par }\pard {\b\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180 {\f5 None. This property calls no actual WinSock calls. This property merely reports the current number of characters in the send buffer.
\par }\pard {\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 Integer
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180\tx3510 {\f5 VB1.0+/VC++
\par }\pard {\b\f5 \page }{\b\f5\fs22 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_SENDCOUNT}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb Recv}{\f5\uldb Count}{\v\f5 NETCLIENT_PROPERTY_RECVCOUNT}{\f5\uldb 
\par }{\f5\uldb RecvSize}{\v\f5 NETCLIENT_PROPERTY_RECVSIZE}{\f5\uldb 
\par }{\f5\uldb SendSize}{\v\f5 NETCLIENT_PROPERTY_SENDSIZE}{\f5 
\par }{\f5\uldb RecvThreshold}{\v\f5 NETCLIENT_PROPERTY_RECVTHRESHOLD}{\f5\uldb 
\par }{\f5\uldb SendThreshold}{\v\f5 NETCLIENT_PROPERTY_SENDTHRESHOLD}{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_SENDLINE}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient SendLine Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;SendLine}}{\plain \b\f5\lang1033 SendLine Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_SENDLINE}{\b\f5 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180 {\b\f5 SendLine}{\f5  allows an application to talk in ASCII text to a remote host.}{\b\f5 
\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 SendLine}{\i\f5  =}{\f5 [}{\i\f5 lineoutput$}{\f5 ]
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 SetStrProperty("SendLine",}{\i\f5  lineoutput$}{\b\f5 )
\par }\pard {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180 {\b\f5 Se}{\b\f5 ndLine}{\f5  uses the older HSZ property type. Unlike the }{\f5\uldb SendBlock}{\v\f5 NETCLIENT_PROPERTY_SENDBLOCK}{\f5  property, embedded Null characters (Chr$(0)) are }{\i\f5 NOT}{\f5  permitted.
\par }{\f5 
\par }{\b\f5 SendLine}{\f5  will put whatever is handed to it as a VB string into in the send buffer.
\par }{\f5 
\par }{\b\f5 SendLine}{\f5  does NOT use the }{\f5\uldb LineDelimiter}{\v\f5 NETCLIENT_PROPERTY_LINEDELIMITER}{\f5  property; all strings sent through }{\b\f5 SendLine}{\f5 
 are sent as specified. You must include end-of-line terminators in the string you are sending.
\par }{\f5 
\par }{\f5 You may send multiple lines at a time, but do not excee}{\f5 d the value of }{\f5\uldb SendSize}{\v\f5 NETCLIENT_PROPERTY_SENDSIZE}{\f5  minus }{\f5\uldb SendCount}{\v\f5 NETCLIENT_PROPERTY_SENDCOUNT}{\f5  'lest you chance a GPF.
\par }{\f5 
\par }\pard {\b\f5 WinSock Calls
\par }\pard \li180 {\f5 This property calls send() until either:
\par }\pard \li360 {\b\f5 1)}{\f5  All of the handed data is accepted by the WinSock.DLL
\par }{\b\f5 2)}{\f5  The send() call returns WSAEWOULDBLOCK
\par }\pard \li180 {\f5 In the second case, a flag is set so that no more send attempts are made until an FD_WRITE message is posted to the control's window by the WinSock.DLL. When this message is posted, the flag is cleared, and an attempt at sending uns}{
\f5 ent data is again attempted.
\par }\pard {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 String}{\f5  (HSZ)
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180\tx3510 {\f5 VB2.0+
\par }\pard {\b\f5 \page }{\b\f5\fs22 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_SENDLINE}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb RecvBlock}{\v\f5 NETCLIENT_PROPERTY_RECVBLOCK}{\f5 
\par }{\f5\uldb Block}{\v\f5 NETCLIENT_PROPERTY_BLOCK}{\f5\uldb 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_SENDSIZE}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient SendSize Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;SendSize}}{\plain \b\f5\lang1033 SendSize Property, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_SENDSIZE}{\b\f5 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 The }{\b\f5 SendSize}{\f5  property is used to set the size of the receive }{\f5\ul FIFO}{\v\f5 POPUP_FIFO}{\f5  buffer.
\par }\pard \tx3510 {\b\f5 
\par }\pard {\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 SendSize}{\f5 [}{\i\f5 = size%}{\f5 ]
\par }{\f5 [}{\i\f5 size%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 SendSize}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetNumProperty("SendSize")}{\f5 
\par }{\f5 pNetClient->}{\b\f5 SetNumProperty(}{\b\f5 "SendSize",}{\f5  }{\i\f5 size%}{\b\f5 )
\par }\pard {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 By default, this property holds the value returned by a getsockopt() call for SO_SNDBUF immediately before an }{\f5\uldb OnConnect()}{\v\f5 NETCLIENT_EVENT_ONCONNECT}{\f5 
 event, or a saved value from design time, which ever is greater.
\par }{\f5 
\par }{\f5 Setting this property will force the NetClient control to TRY and resize the send }{\f5\ul FIFO}{\v\f5 POPUP_FIFO}{\f5  buffer size to the size specified. 
\par }{\f5 
\par }{\f5 Getting this property will return the CURRENT size of the send }{\f5\ul FIFO}{\v\f5 POPUP_FIFO}{\f5  buffer.
\par }{\f5 
\par }\pard {\b\f5 WinSock Calls
\par }\pard \li180 {\f5 If there is data in the se}{\f5 nd buffer, the NetClient control will attempt to flush it to the WinSock send buffers through send(). If the send buffer is then empty, or was empty initially empty, the Global buffer is reallocated.

\par }\pard {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 Integer}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard {\b\f5\fs22 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_SENDSIZE}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb RecvSize}{\v\f5 NETCLIENT_PROPERTY_RECVSIZE}{\f5\uldb 
\par }{\f5\uldb SendCount}{\v\f5 NETCLIENT_PROPERTY_RECVCOUNT}{\f5\uldb 
\par }{\f5\uldb RecvCount}{\v\f5 NETCLIENT_PROPERTY_RECVCOUNT}{\f5 
\par }{\f5\uldb RecvThreshold}{\v\f5 NETCLIENT_PROPERTY_RECVTHRESHOLD}{\f5\uldb 
\par }{\f5\uldb SendThreshold}{\v\f5 NETCLIENT_PROPERTY_SENDTHRESHOLD}{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_SENDTHRESHOLD}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient SendThreshold Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;SendThreshold}}{\plain \b\f5\lang1033 SendThreshold Property, NetClient Control}{\plain \b\f5\lang1033 
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_SENDTHRESHOLD}{\b\f5 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\b\f5 SendThreshold}{\f5  specifies the lowest number of characters allowed to be queued in the send buffer before the }{\f5\uldb OnSend()}{\v\f5 NETCLIENT_EVENT_ONSEND}{\f5  event is fired.
\par }{\f5 
\par }\pard {\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 SendThreshold}{\f5 [}{\i\f5 = size%}{\f5 ]
\par }{\f5 [}{\i\f5 size%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 SendThreshold}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetNumProperty("SendThreshold")}{\f5 
\par }{\f5 pNetClient->}{\b\f5 SetNumProperty("SendThreshold",}{\f5  }{\i\f5 size%}{\b\f5 )
\par }\pard \tx3510 {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 By default, this property is set to 0. This means that when the send bu}{\f5 ffer empties, an }{\f5\uldb OnSend()}{\v\f5 NETCLIENT_EVENT_ONSEND}{\f5  event will be fired.
\par }{\f5 
\par }{\f5 This property can be set to any value in order to allow your application to maintain a full streaming connection.
\par }{\f5 
\par }\pard \li180 {\f5 This property is of enormous use to those programs that send large }{\i\f5 chunks}{\f5  of data. If your application is a bandwidth glutton, you will want to set this property to something akin to the initial value of }{\f5\uldb 
SendSize}{\v\f5 NETCLIENT_PROPERTY_SENDSIZE}{\f5  (which, by default, returns the size from a getsockopt() with SO_SNDBUF). This will}{\f5  insure that your application keeps the underlying WinSock.DLL busy sending data.
\par }{\f5 
\par }\pard \li360\brdrt\brdrs\brdrw30\brsp20 \brdrb\brdrs\brdrw30\brsp20 {\b\f5 Note: }{\f5 You MUST either use this property and the }{\f5\uldb OnSend()}{\v\f5 NETCLIENT_EVENT_ONSEND}{\f5  event, or you must poll }{\f5\uldb SendCount}{\v\f5 
NETCLIENT_PROPERTY_SENDCOUNT}{\f5  in a }{\f7\cf2 DoEvents}{\f5  style loop in order to send more data than }{\f5\uldb SendSize}{\v\f5 NETCLIENT_PROPERTY_SENDSIZE}{\f5 
 bytes. If you do not, the NetClient control will trigger a WSAERR_SendOverflow(20004) VB error as soon as you overflow your WINSOCK.DLL's buffer and the NetClient control's send buffer. 
\par }\pard \li180 {\b\f5 
\par }\pard {\b\f5 Win}{\b\f5 Sock Calls
\par }\pard \li180 {\f5 None.
\par }\pard {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 Integer
\par }\pard {\b\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard {\b\f5\fs22 \page #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_SENDTHRESHOLD}}{\b\f5\fs22 See also
\par }\pard \li180 {\f5\uldb RecvThreshold}{\v\f5 NETCLIENT_PROPERTY_RECVTHRESHOLD}{\f5 
\par }{\f5\uldb SendSize}{\v\f5 NETCLIENT_PROPERTY_SENDSIZE}{\f5\uldb 
\par }{\f5\uldb RecvSize}{\v\f5 NETCLIENT_PROPERTY_RECVSIZE}{\f5\uldb 
\par }{\f5\uldb SendCount}{\v\f5 NETCLIENT_PROPERTY_RECVCOUNT}{\f5\uldb 
\par }{\f5\uldb RecvCount}{\v\f5 NETCLIENT_PROPERTY_RECVCOUNT}{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_SOCKET}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient Socket Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;Socket}}{\plain \b\f5\lang1033 Socket Property, NetClient Control
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\b\f5 Socket}{\f5  specifies the actual socket number from a valid WinSock connection.
\par }{\f5 
\par }\pard {\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 Socket}{\i\f5 =}{\f5 [}{\i\f5  socket%}{\f5 ]
\par }{\f5 [}{\i\f5 size%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 Socket}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNet}{\f5 Client->}{\b\f5 GetNumProperty("Socket")}{\f5 
\par }{\f5 pNetClient->}{\b\f5 SetNumProperty("Socket",}{\f5  }{\i\f5 socket%}{\b\f5 )
\par }\pard \tx3510 {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 If }{\f5\uldb Connect}{\v\f5 NETCLIENT_PROPERTY_CONNECT}{\f5  is }{\f5\cf2 False}{\f5 , this property has no meaning when read. The socket() call is not made until the }{\f5\uldb Connect}{\v\f5 NETCLIENT_PROPERTY_CONNECT}{\f5 
 property is set.
\par }{\f5 
\par }{\f5 If }{\f5\uldb Connect}{\v\f5 NETCLIENT_PROPERTY_CONNECT}{\f5  is }{\f5\cf2 False}{\f5 , and you set this property to either 0 or SOCKET_ERROR (-1), the }{\f5\uldb Connect}{\v\f5 NETCLIENT_PROPERTY_CONNECT}{\f5  property will be set to }{\f5\cf2 
False}{\f5  - regardless. 
\par }{\f5 
\par }{\f5 During the period of setting }{\f5\uldb Connect}{\v\f5 NETCLIENT_}{\v\f5 PROPERTY_CONNECT}{\f5  to }{\f5\cf2 True}{\f5 , and an }{\f5\uldb OnConnect()}{\v\f5 NETCLIENT_EVENT_ONCONNECT}{\f5  or OnError() event occuring, the }{\b\f5 Socket}{\f5 
 property }{\i\f5 IS}{\f5  valid, albeit not connected.
\par }{\f5 
\par }{\f5 If }{\f5\uldb Connect}{\v\f5 NETCLIENT_PROPERTY_CONNECT}{\f5  is }{\f5\cf2 True}{\f5 , this property holds the return value of a socket() call - which, due to the fact that it is connected, is bound on both sides and ready for communication.
\par }{\f5 
\par }{\f5 Whenever you set the }{\b\f5 Socket}{\f5  property with a valid WinSock Socket, }{\f5\uldb Connect}{\v\f5 NETCLIENT_PROPERTY_CONNECT}{\f5  will be set to }{\f5\cf2 True}{\f5 , and getpeername() will be used to}{\f5  try and set }{\f5\uldb HostAddr}{
\v\f5 NETCLIENT_PROPERTY_HOSTADDR}{\f5 . The WSAAsyncSelect() call is also used to set up asyncronous message processing for the Socket, which can break older WinSocks from certain vendors (as they have assumed you will call WSAAsyncSelect() only once).

\par }{\f5 
\par }{\f5 When you use the }{\f5\uldb NetServer}{\v\f5 TOPIC_CONTROL_NETSERVER}{\f5  control to listen for incoming connections, you MUST use this property in it's }{\f5\uldb OnAccept()}{\v\f5 NETSERVER_EVENT_ONACCEPT}{\f5 
 event in order to start a connection. 
\par }{\f5 
\par }{\f5 Do }{\i\f5 NOT}{\f5  attempt a closesocket() on this h}{\f5 andle. It will not currently have any adverse affects (other than sporadic errors), but it might in future versions. Do }{\i\f5 NOT}{\f5  set this }{\b\f5 Socket}{\f5  to blocking, and do }
{\i\f5 NOT}{\f5  do a WSAAsyncSelect() on }{\b\f5 Socket}{\f5 , as it will surely break the current control. 
\par }{\f5 
\par }{\f5 For further reference, you may want to consult }{\f5\uldb What is a Socket?}{\v\f5 TOPIC_SOCKET}{\f5  and the WinSock.HLP file.
\par }\pard \tx3510 {\b\f5 
\par }\pard {\b\f5 WinSock Calls
\par }\pard \li180 {\f5 None.
\par }\pard {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 Integer
\par }\pard {\b\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_TIMEOUT}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient TimeOut Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;TimeOut}}{\plain \b\f5\lang1033 TimeOut Property, NetClient Control
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\b\f5 TimeOut }{\f5 specifies the timeout period (in}{\f5  seconds) for starting the }{\f5\uldb OnTimeOut()}{\v\f5 NETCLIENT_EVENT_ONTIMEOUT}{\f5  event. 
\par }{\f5 
\par }\pard {\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 TimeOut}{\i\f5 =}{\f5 [}{\i\f5  seconds%}{\f5 ]
\par }{\f5 [}{\i\f5 seconds%}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 TimeOut}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetNumProperty("TimeOut")
\par }{\f5 pNetClient->}{\b\f5 SetNumProperty("TimeOut",}{\f5  }{\i\f5 seconds%}{\b\f5 )
\par }\pard \tx3510 {\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 Setting this property to a non zero value sets the number of seconds, from the time of setting, before the }{\f5\uldb OnTimeOut()}{\v\f5 NETCLIENT_EVENT_ONTIMEOUT}{\f5  event is fired.
\par }{\f5 
\par }{\f5 Setting this property to zero will }{\i\f5 disable}{\f5  the pending }{\f5\uldb OnTimeOut()}{\v\f5 NETCLIENT_EVENT_ONTIMEOUT}{\f5  event.
\par }{\f5 
\par }{\f5 Reading the }{\b\f5 TimeOut}{\f5  property at any time will tell you how many more seconds }{\i\f5 remain}{\f5  until the timeout will occur.
\par }{\f5 
\par }{\f5 This property and event pair emulate the functionality of the Timer control.
\par }{\f5 
\par }\pard {\b\f5 WinSock Calls
\par }\pard \li180 {\f5 None.
\par }\pard {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 Integer
\par }\pard {\b\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_PROPERTY_VERSION}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient Version Property}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Properties;Version}}{\plain \b\f5\lang1033  Version Property, NetClient Control
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 This property reports the current revision of the NetClient control. The current version of }{\i\f5 THIS}{\f5  WSANET.VBX distribution will return "v1.08alpha" as the versi}{\f5 on string.
\par }\pard {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180 {\f5 [}{\i\f5 version$}{\f5 ]}{\i\f5  = }{\f5 [}{\i\f5 form .}{\f5 ]}{\i\f5  NetClient}{\f5 .}{\b\f5 Version}{\f5 
\par }\pard {\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180 {\f5 pNetClient->}{\b\f5 GetStrProperty("Version")}{\f5 
\par }\pard {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 This property can }{\i\f5 NOT}{\f5  be set.
\par }{\f5 
\par }{\f5  You can use this property at run time to warn the user that the application may, }{\i\f5 or may not}{\f5 
, work with any newer version of the control. The NetClient control currently has 8 reserved properties that can be used before any incompatibilities will occur. Hopefully, no more than 8 additional VB1.0 properties will needed to make this control do ev}
{\f5 erything WinSock can do. Visual Basic 2.0 properties can be added at the end of the properties list, so no future incompatibilities should occur.
\par }\pard \tx3510 {\b\f5 
\par }\pard \li180\tx3510 {\f5 This string is merely a way for programmers to deal with known incompatibilities of WSANET.VBX versions, and to report version information to the user. This is }{\i\f5 NOT}{\f5 
 the way for an application to realize the version of WinSock it is using - this version of WSANET does }{\i\f5 NOT}{\f5  support any version beside WinSock v1.1.
\par }\pard {\b\f5 
\par }{\b\f5 WinSock Calls
\par }\pard \li180 {\f5 None.
\par }\pard {\b\f5 
\par }{\b\f5 Data Type
\par }\pard \li180 {\b\f5 String }{\f5 (Hsz)}{\f5 
\par }\pard {\b\f5 
\par }{\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard \tx3510 {\b\f5 \page }{\fs16\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_EVENTS}}{\b\f5  }{\b\f5\fs22 See Also
\par }\pard \ri7290\tx3510 {\f5\uldb OnConnect}{\v\f5 NETCLIENT_EVENT_ONCONNECT}{\f5 
\par }{\f5\uldb OnClose}{\v\f5 NETCLIENT_EVENT_ONCLOSE}{\f5 
\par }{\f5\uldb OnError}{\v\f5 NETCLIENT_EVENT_ONERROR}{\f5 
\par }{\f5\uldb OnRecv}{\v\f5 NETCLIENT_EVENT_ONRECV}{\f5 
\par }{\f5\uldb OnSend}{\v\f5 NETCLIENT_EVENT_ONSEND}{\f5 
\par }{\f5\uldb OnTimeOut}{\v\f5 NETCLIENT_EVENT_ONTIMEOUT}{\f5 
\par }{\f5 
\par }{\f5\uldb Using Events}{\v\f5 !JK("ctrlref.hlp", "Events, Using")}{\f5 
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_EVENT_ONCONNECT}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient OnConnect() Event}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Events;OnConnect()}}{\plain \b\f5\lang1033  OnConnect Event, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_EVENTS}{\f5\fs18 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 Generated whenever a connection is made to a remote host.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180\tx3510 {\b\f5 Sub }{\i\f5 NetClient}{\b\f5 _OnConnect(}{\f5 [}{\i\f5 Index}{\b\f5  As Integer}{\f5 ]}{\b\f5 )
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180\tx3510 {\f5 F}{\f5 unction Signature:
\par }{\b\f5 void }{\i\f5 CMyDialog::On Outline OnConnect}{\b\f5 (UINT, int, CWnd*, LPVOID lpParams)
\par }\pard \tx3510 {\b\f5 
\par }\pard \li180\tx3510 {\f5 Parameter Usage:
\par }{\f5 None.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 The }{\b\f5 OnConnect()}{\f5  event is generated whenever a connection to a remote host is completed. This event is fired in response to the }{\f5\uldb Connect}{\v\f5 NETCLIENT_PROPERTY_CONNECT}{\f5 
 property being set to True, and a connection to a remote host successfully completing.
\par }{\f5 
\par }{\f5 This event will not be fired if a connection can not be made with the specified remote host. Instead, the OnError() event will be }{\f5 called with an appropriate WinSock error.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 WinSock Events
\par }\pard \li180\tx3510 {\f5 This event is fired on response to an FD_CONNECT message.
\par }\pard \keepn\tx3510 {\b\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_EVENT_ONCLOSE}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient OnClose() Event}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Events;OnClose()}}{\plain \b\f5\lang1033  OnClose Event, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_EVENTS}{\f5\fs18 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 Generated whenever a connection to a remote host is lost.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180\tx3510 {\b\f5 Sub }{\i\f5 NetClient}{\b\f5 _OnClose(}{\f5 [}{\i\f5 Index}{\b\f5  As Integer}{\f5 ]}{\b\f5 )
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180\tx3510 {\f5 Function Signature:
\par }{\b\f5 void }{\i\f5 CMyDialog::On Outline OnClose}{\b\f5 (UINT, int, CWnd*, LPVOID lpParams)
\par }\pard \tx3510 {\b\f5 
\par }\pard \li180\tx3510 {\f5 Parameter Usage:
\par }{\f5 None.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 The }{\b\f5 OnClose()}{\f5  event is generated whene}{\f5 ver a connection to a remote host is lost. 
\par }{\f5 
\par }{\f5 This event is }{\i\f5 NOT}{\f5  fired due to your application setting the }{\f5\uldb Connect}{\v\f5 NETCLIENT_PROPERTY_CONNECT}{\f5  property to }{\f5\cf2 False}{\f5 .
\par }{\f5 
\par }{\f5 This event will }{\i\f5 NOT}{\f5  occur until after connection to a remote host is established.
\par }{\f5 
\par }\pard \tx3510 {\b\f5 WinSock Events
\par }\pard \li180\tx3510 {\f5 This event is fired on response to either an FD_CLOSE message or a 0 return by recv().
\par }\pard \keepn\tx3510 {\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_EVENT_ONERROR}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient OnError() Event}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Events;OnError()}}{\plain \b\f5\lang1033  OnError Event, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_EVENTS}{\f5\fs18 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 Generated whenever an error of some kind occurs.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180\tx3510 {\b\f5 Su}{\b\f5 b }{\i\f5 NetClient}{\b\f5 _OnError(}{\f5 [}{\i\f5 Index}{\b\f5  As Integer}{\f5 ], ErrorNumber}{\b\f5  As Integer)
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180\tx3510 {\f5 Function Signature:
\par }{\b\f5 void }{\i\f5 CMyDialog::On Outline OnError}{\b\f5 (UINT, int, CWnd*, LPVOID lpParams)
\par }\pard \tx3510 {\b\f5 
\par }\pard \li180\tx3510 {\f5 Parameter Usage:
\par }{\f5 None.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 The }{\b\f5 OnError()}{\f5  event is generated whenever an error occurs.
\par }{\f5 
\par }{\f5 The }{\b\f5 ErrorNumber}{\f5  value and }{\f5\uldb ErrorMessage}{\v\f5 NETCLIENT_PROPERTY_ERRORMESSAGE}{\f5  property can be used to identify the error that occurred.
\par }{\f5 
\par }\pard \tx3510 {\b\f5 WinSock Events
\par }\pard \li180\tx3510 {\f5 This event is fired whenever an error occurs. WSAGetLastError() is called by the NetClient con}{\f5 trol if the error was WinSock related before the }{\b\f5 OnError()}{\f5  event is fired. 
\par }\pard \keepn\tx3510 {\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_EVENT_ONRECV}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetClient OnRecv() Event
}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Events;OnRecv()}}{\plain \b\f5\lang1033  OnRecv Event, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_EVENTS}{\f5\fs18 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 Generated whenever incoming data is received from a network connection.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180\tx3510 {\b\f5 Sub }{\i\f5 NetClient}{\b\f5 _OnRecv(}{\f5 [}{\i\f5 Index}{\b\f5  As Integer}{\f5 ]}{\b\f5 )
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180\tx3510 {\f5 Function Signature:
\par }{\b\f5 void }{\i\f5 CMyDialog::On Outline OnRecv}{\b\f5 (UINT, int, CWnd*, LPVOID lpParams)
\par }\pard \tx3510 {\b\f5 
\par }\pard \li180\tx3510 {\f5 Parameter Usage:
\par }{\f5 None.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 The }{\b\f5 OnRecv()}{\f5  event is generated whenever the count of incoming data ri}{\f5 ses above the }{\f5\uldb RecvThreshold}{\v\f5 NETCLIENT_PROPERTY_RECVTHRESHOLD}{\f5 .
\par }{\f5 
\par }{\f5 The }{\f5\uldb RecvLine}{\v\f5 NETCLIENT_PROPERTY_RECVLINE}{\f5 /}{\f5\uldb Line}{\v\f5 NETCLIENT_PROPERTY_LINE}{\f5 /}{\f5\uldb LineDelimiter}{\v\f5 NETCLIENT_PROPERTY_LINEDELIMITER}{\f5 
 properties can be used to parse incoming data that does not include embedded NULLs (Chr$(0))
\par }{\f5 
\par }{\f5 The }{\f5\uldb RecvBlock}{\v\f5 NETCLIENT_PROPERTY_RECVBLOCK}{\f5 /}{\f5\uldb Block}{\v\f5 NETCLIENT_PROPERTY_BLOCK}{\f5  properties can be used to parse incoming data that requires binary handling (in VB2.0+ only).
\par }{\f5 
\par }\pard \tx3510 {\b\f5 WinSock Events
\par }\pard \li180\tx3510 {\f5 This event is fired whenever incoming data is receive}{\f5 d. This data is received through the recv() WinSock call during the FD_READ message handler.
\par }\pard \keepn\tx3510 {\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_EVENT_ONSEND}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $} NetClient OnSend() Event
}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Events;OnSend()}}{\plain \b\f5\lang1033  OnSend Event, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_EVENTS}{\f5\fs18 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 Generated whenever data should be sent to the remote host.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180\tx3510 {\b\f5 Sub }{\i\f5 NetClient}{\b\f5 _OnSend(}{\f5 [}{\i\f5 Index}{\b\f5  As Integer}{\f5 ]}{\b\f5 )
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180\tx3510 {\f5 Function Signature:
\par }{\b\f5 void }{\i\f5 CMyDialog::On Outline OnSend}{\b\f5 (UINT, int, CWnd*, LPVOID lpParams)
\par }\pard \tx3510 {\b\f5 
\par }\pard \li180\tx3510 {\f5 Parameter Usage:
\par }{\f5 None.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 The }{\b\f5 OnSend()}{\f5  event is generated whenever the count of incoming dat}{\f5 a drops below the }{\f5\uldb SendThreshold}{\v\f5 NETCLIENT_PROPERTY_SENDTHRESHOLD}{\f5 .
\par }{\f5 
\par }{\f5 The }{\f5\uldb SendLine}{\v\f5 NETCLIENT_PROPERTY_SENDLINE}{\f5  and }{\f5\uldb Line}{\v\f5 NETCLIENT_PROPERTY_LINE}{\f5  properties can be used to send outgoing data that does not include embedded NULLs (Chr$(0))
\par }{\f5 
\par }{\f5 The }{\f5\uldb SendBlock}{\v\f5 NETCLIENT_PROPERTY_RECVBLOCK}{\f5  and }{\f5\uldb Block}{\v\f5 NETCLIENT_PROPERTY_BLOCK}{\f5  properties can be used to send outgoing data that requires binary handling (in VB2.0+ only).
\par }{\f5 
\par }\pard \tx3510 {\b\f5 WinSock Events
\par }\pard \li180\tx3510 {\f5 This Event is typically the response to an FD_WRITE message that allowed the send buffer }{\f5 to drop below the }{\f5\uldb SendThreshold}{\v\f5 NETCLIENT_PROPERTY_SENDTHRESHOLD}{\f5 .
\par }\pard \keepn\tx3510 {\f5 \page }{\plain \f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} NETCLIENT_EVENT_ONTIMEOUT}}{\plain \f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClient OnTimeOut() Event}}{\plain \f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Events;OnTimeOut()}}{\plain \b\f5\lang1033  OnTimeOut Event, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_EVENTS}{\f5\fs18 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 Generated whenever the timeout period has expired.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Visual Basic
\par }\pard \li180\tx3510 {\b\f5 Sub }{\i\f5 NetClient}{\b\f5 _OnSend(}{\f5 [}{\i\f5 Index}{\b\f5  As Integer}{\f5 ]}{\b\f5 )
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Visual C++
\par }\pard \li180\tx3510 {\f5 Function Signature:
\par }{\b\f5 void }{\i\f5 CMyDialog::On Outline OnTimeOut}{\b\f5 (UINT, int, CWnd*, LPVOID lpParams)
\par }\pard \tx3510 {\b\f5 
\par }\pard \li180\tx3510 {\f5 Parameter Usage:
\par }{\f5 None.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 The }{\b\f5 OnTimeOut()}{\f5  event is generated whenever the desired timer period has elapsed. 
\par }{\f5 
\par }{\f5 By setting}{\f5  the }{\f5\uldb TimeOut}{\v\f5 NETCLIENT_PROPERTY_TIMEOUT}{\f5  property to a non-zero value, your application is setting the number of seconds before the}{\b\f5  OnTimeOut()}{\f5  event occurs.
\par }{\f5 
\par }{\f5 This event the response to the }{\f5\uldb TimeOut}{\v\f5 NETCLIENT_PROPERTY_TIMEOUT}{\f5  property reaching 0. This event is one-shot only; after this event occurs, it will not occur again unless the }{\f5\uldb TimeOut}{\v\f5 
NETCLIENT_PROPERTY_TIMEOUT}{\f5  property is set again.
\par }\pard \tx3510 {\b\f5 
\par }{\b\f5 WinSock Events
\par }\pard \li180\tx3510 {\f5 None.
\par }\pard \keepn\tx3510 {\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #}EXPORT_NETCLIENTSENDBLOCK}}{\plain \b\f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClientSendBlock() Export}}{\plain \b\f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Exports;NetClientSendBlock() Export}}{\plain \b\f5\lang1033  NetClientSendBlock() Export, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_NETCLIENTS}{\v\f5\fs18 ENDBLOCK}{\f5\fs18\uldb 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 This function will send any Visual Basic string as binary to a remote host.
\par }{\f5 
\par }\pard \tx3510 {\b\f5 Visual Basic
\par }\pard \li180\tx3510 {\f5 Declare Function }{\b\f5 NetClientSendBlock}{\f5  Lib "WSANET.VBX" (cControl As NetClient, sString As String) As Integer
\par }{\f5 
\par }\pard \tx3510 {\b\f5 Visual C++
\par }\pard \li180\tx3510 {\f5 int CALLBACK }{\b\f5 NetClientSendBlock}{\f5 (HCTL, HLSTR);
\par }{\f5 
\par }\pard \li180\brdrt\brdrs\brdrw30\brsp20 \brdrb\brdrs\brdrw30\brsp20 \tx3510 {\f5 NOTE: I do not know the declarations in order to let VC++ pass a VB string to a function.
\par }\pard \li180\tx3510 {\f5 
\par }\pard \tx3510 {\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 This function supports the transmission of binary data through the NetClient control. This procedure is exported as a C sty}{\f5 le }{\i\f5 function}{\f5 
 that accepts a Visual Basic string as a parameter (note the absence of the ByVal keyword).
\par }{\f5 
\par }{\f5 If you are able to use VB2.0+ HLSTR properties, then you will probably want to use the }{\f5\uldb Block}{\v\f5 NETCLIENT_PROPERTY_BLOCK}{\f5  series of properties.
\par }{\f5 
\par }{\f5 If you need to receive binary data through VB1.0 or VC++, you will need to use the }{\f5\uldb NetClientRecvBlock()}{\v\f5 EXPORT_NETCLIENTRECVBLOCK}{\f5  function.
\par }{\f5 
\par }\pard \tx3510 {\b\f5 WinSock Calls
\par }\pard \li180\tx3510 {\f5 send()
\par }{\f5 
\par }\pard {\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard \li180\tx3510 {\f5 \page }{\b\f5\fs22\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_NETCLIENTSENDBLOCK}}{\b\f5\fs22  See Also
\par }{\f5\uldb NetClientRecvBlock}{\v\f5 EXPORT_NETCLIENTRECVBLOCK}{\f5 
\par }{\f5\uldb Block}{\v\f5 NETCLIENT_PROP}{\v\f5 ERTY_BLOCK}{\f5 
\par }{\f5\uldb SendBlock}{\v\f5 NETCLIENT_PROPERTY_SENDBLOCK}{\f5 
\par }{\f5\uldb RecvBlock}{\v\f5 NETCLIENT_PROPERTY_RECVBLOCK}{\f5 
\par }\pard \keepn\tx3510 {\f5 \page }{\plain \b\f5\up6\lang1033 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #}EXPORT_NETCLIENTRECVBLOCK}}{\plain \b\f5\up6\lang1033 ${\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 $}
 NetClientRecvBlock() Export}}{\plain \b\f5\up6\lang1033 K{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 K} Exports;NetClientRecvBlock() Export}}{\plain \b\f5\lang1033  NetClientRecvBlock() Export, NetClient Control
\par }{\f5\fs18\ul See Also}{\v\f5\fs18 POPUP_NETCLIENT_SEEALSO_NETCLIENTRECVBLOCK}{\f5\fs18\uldb 
\par }\pard \tx3510 {\b\f5 Description
\par }\pard \li180\tx3510 {\f5 This function will receive any Visual Basic string as binary from a remote host.
\par }{\f5 
\par }\pard \tx3510 {\b\f5 Visual Basic
\par }\pard \li180\tx3510 {\f5 Declare Function }{\b\f5 NetClientRecvBlock}{\f5  Lib "WSANET.VBX" (cControl As NetClient, sString As String, iNumber As Integer) As Integer
\par }{\f5 
\par }\pard \tx3510 {\b\f5 Visual C++
\par }\pard \li180\tx3510 {\f5 int CALLBACK }{\b\f5 NetClientRecvBlock}{\f5 (HCTL, HLSTR, int);
\par }{\f5 
\par }\pard \li180\brdrt\brdrs\brdrw30\brsp20 \brdrb\brdrs\brdrw30\brsp20 \tx3510 {\f5 NOTE: I do}{\f5  not know the declarations in order to let VC++ pass a VB string to a function.
\par }\pard \li180\tx3510 {\f5 
\par }\pard \tx3510 {\b\f5 Remarks
\par }\pard \li180\tx3510 {\f5 This function supports the transmission of binary data through the NetClient control. This procedure is exported as a C style }{\i\f5 function}{\f5 
 that accepts a Visual Basic string as a parameter (note the absence of the ByVal keyword).
\par }{\f5 
\par }{\f5 If you are able to use VB2.0+ HLSTR properties, then you will probably want to use the }{\f5\uldb Block}{\v\f5 NETCLIENT_PROPERTY_BLOCK}{\f5  series of properties.
\par }{\f5 
\par }{\f5 If you need to send binary data through VB1.0 or }{\f5 VC++, you will need to use the }{\f5\uldb NetClientSendBlock()}{\v\f5 EXPORT_NETCLIENTSENDBLOCK}{\f5  function.
\par }{\f5 
\par }\pard \tx3510 {\b\f5 WinSock Calls
\par }\pard \li180\tx3510 {\f5 This function doesn't  use any WinSock routines. Anything that this function returns is merely buffered data that }{\i\f5 WAS}{\f5  received by the recv() function call in the FD_READ message handler for the control.
\par }{\f5 
\par }\pard {\b\f5 Scope
\par }\pard \li180 {\f5 VB1.0+/VC++
\par }\pard \li180\tx3510 {\f5 \page }{\b\f5\fs22\up6 #{\footnote \pard\plain \s245 \f3\fs20\lang1033 {\fs16\up6 #} POPUP_NETCLIENT_SEEALSO_NETCLIENTRECVBLOCK}}{\b\f5\fs22  See Also
\par }{\f5\uldb NetClientSendBlock}{\v\f5 EXPORT_NETCLIENTSENDBLOCK}{\f5 
\par }{\f5\uldb Block}{\v\f5 NETCLIENT_PROPERTY_BLOCK}{\f5 
\par }{\f5\uldb SendBlock}{\v\f5 NETCLIENT_PROPERTY_SENDBLOCK}{\f5 
\par }{\f5\uldb RecvBlock}{\v\f5 NETCLIENT_PROPERTY_RECVBLOCK}{\f5 
\par }{\f5 
\par }}